[{"filePath":"/app/core/PlanExecutor.js","messages":[{"ruleId":"security/detect-object-injection","severity":1,"message":"Function Call Object Injection Sink","line":58,"column":62,"nodeType":"MemberExpression","endLine":58,"endColumn":87},{"ruleId":"no-unused-vars","severity":1,"message":"'parentTaskId' is defined but never used. Allowed unused args must match /^_/u.","line":106,"column":89,"nodeType":"Identifier","messageId":"unusedVar","endLine":106,"endColumn":101},{"ruleId":"security/detect-object-injection","severity":1,"message":"Variable Assigned to Object Injection Sink","line":360,"column":49,"nodeType":"MemberExpression","endLine":360,"endColumn":62},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":435,"column":137,"nodeType":"MemberExpression","endLine":435,"endColumn":147},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":436,"column":44,"nodeType":"MemberExpression","endLine":436,"endColumn":59},{"ruleId":"security/detect-object-injection","severity":1,"message":"Variable Assigned to Object Injection Sink","line":545,"column":41,"nodeType":"MemberExpression","endLine":545,"endColumn":56},{"ruleId":"security/detect-object-injection","severity":1,"message":"Variable Assigned to Object Injection Sink","line":546,"column":44,"nodeType":"MemberExpression","endLine":546,"endColumn":74}],"suppressedMessages":[{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":46,"column":21,"nodeType":"MemberExpression","endLine":46,"endColumn":46,"suppressions":[{"kind":"directive","justification":"sourceStepId is validated by hasOwnProperty call above. Accessing .status property."}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":48,"column":114,"nodeType":"MemberExpression","endLine":48,"endColumn":139,"suppressions":[{"kind":"directive","justification":"sourceStepId is validated by hasOwnProperty call above. Accessing .status property for error message."}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Variable Assigned to Object Injection Sink","line":53,"column":37,"nodeType":"MemberExpression","endLine":53,"endColumn":79,"suppressions":[{"kind":"directive","justification":"sourceStepId is validated by hasOwnProperty, actualFieldName is from allowed list or checked with hasOwnProperty."}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":53,"column":37,"nodeType":"MemberExpression","endLine":53,"endColumn":62,"suppressions":[{"kind":"directive","justification":"sourceStepId is validated by hasOwnProperty, actualFieldName is from allowed list or checked with hasOwnProperty."}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":62,"column":41,"nodeType":"MemberExpression","endLine":62,"endColumn":83,"suppressions":[{"kind":"directive","justification":"sourceStepId and actualFieldName (now 'result_data') are validated."}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":62,"column":41,"nodeType":"MemberExpression","endLine":62,"endColumn":66,"suppressions":[{"kind":"directive","justification":"sourceStepId and actualFieldName (now 'result_data') are validated."}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Function Call Object Injection Sink","line":74,"column":59,"nodeType":"MemberExpression","endLine":74,"endColumn":84,"suppressions":[{"kind":"directive","justification":"sourceStepId is validated by hasOwnProperty. Using stepOutputs[sourceStepId] as context for hasOwnProperty check on actualFieldName."}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":89,"column":17,"nodeType":"MemberExpression","endLine":89,"endColumn":29,"suppressions":[{"kind":"directive","justification":"'key' is from 'data' (part of sub_task_input from plan). 'newData' is a fresh, local object, limiting impact. Plan generation should ensure 'key' is not malicious (e.g., '__proto__')."}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Function Call Object Injection Sink","line":89,"column":68,"nodeType":"MemberExpression","endLine":89,"endColumn":77,"suppressions":[{"kind":"directive","justification":"'key' is from 'data' (part of sub_task_input from plan). 'newData' is a fresh, local object, limiting impact. Plan generation should ensure 'key' is not malicious (e.g., '__proto__')."}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":164,"column":42,"nodeType":"MemberExpression","endLine":164,"endColumn":61,"suppressions":[{"kind":"directive","justification":"k is a controlled integer index. Accessing known properties."}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":164,"column":87,"nodeType":"MemberExpression","endLine":164,"endColumn":106,"suppressions":[{"kind":"directive","justification":"k is a controlled integer index. Accessing known properties."}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":166,"column":21,"nodeType":"MemberExpression","endLine":166,"endColumn":40,"suppressions":[{"kind":"directive","justification":"k is a controlled integer index. Accessing known properties."}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":166,"column":74,"nodeType":"MemberExpression","endLine":166,"endColumn":93,"suppressions":[{"kind":"directive","justification":"k is a controlled integer index. Accessing known properties."}]},{"ruleId":"security/detect-non-literal-regexp","severity":1,"message":"Found non-literal argument to RegExp Constructor","line":270,"column":41,"nodeType":"NewExpression","endLine":270,"endColumn":87,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Variable Assigned to Object Injection Sink","line":272,"column":41,"nodeType":"MemberExpression","endLine":272,"endColumn":58,"suppressions":[{"kind":"directive","justification":"'key' is from 'promptParams' own properties, checked by hasOwnProperty. Value used for template filling."}]},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found mkdir from package \"fs\" with non literal argument at index 0","line":424,"column":39,"nodeType":"CallExpression","endLine":424,"endColumn":87,"suppressions":[{"kind":"directive","justification":"taskWorkspaceDir is constructed from base path and system-generated parentTaskId."}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Function Call Object Injection Sink","line":441,"column":58,"nodeType":"MemberExpression","endLine":441,"endColumn":73,"suppressions":[{"kind":"directive","justification":"'operation' is validated against an allowed list derived from tool's prototype methods."}]},{"ruleId":"no-undef","severity":2,"message":"'subTaskDefinition' is not defined.","line":556,"column":81,"nodeType":"Identifier","messageId":"undef","endLine":556,"endColumn":98,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-undef","severity":2,"message":"'originalSubTaskDef' is not defined.","line":711,"column":83,"nodeType":"Identifier","messageId":"undef","endLine":711,"endColumn":101,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-undef","severity":2,"message":"'originalSubTaskDef' is not defined.","line":711,"column":165,"nodeType":"Identifier","messageId":"undef","endLine":711,"endColumn":183,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// core/PlanExecutor.js\nconst { v4: uuidv4 } = require('uuid');\nconst path = require('path'); // Added for workspace path construction\nconst fsp = require('fs').promises; // Added for mkdir\nconst { escapeRegExp } = require('../utils/localization'); // Import the escape function\n\nconst ReadWebpageTool = require('../tools/ReadWebpageTool');\nconst FileSystemTool = require('../tools/FileSystemTool'); // Added\nconst FileDownloaderTool = require('../tools/FileDownloaderTool'); // Added\n\nclass PlanExecutor {\n    constructor(subTaskQueue, resultsQueue, aiService, tools = {}, savedTasksBaseDir) { // Changed llmService to aiService\n        this.subTaskQueue = subTaskQueue;\n        this.resultsQueue = resultsQueue;\n        this.aiService = aiService; // Changed llmService to aiService\n        this.tools = tools;\n        this.savedTasksBaseDir = savedTasksBaseDir; // Store this\n        if (!this.savedTasksBaseDir) {\n            // Fallback or error if not provided by Orchestrator, though it should be.\n            console.warn(\"PlanExecutor: savedTasksBaseDir not provided, defaulting to './saved_tasks'. This may be incorrect.\");\n            this.savedTasksBaseDir = path.resolve('./saved_tasks');\n        }\n    }\n\n    async _resolveOutputReferences(data, stepOutputs, currentStepIdForLog = '') {\n        const referenceRegex = /^@{outputs\\.([a-zA-Z0-9_.-]+)\\.(result_data|processed_result_data)}$/; // Full string match\n\n        if (typeof data === 'string') {\n            const match = data.match(referenceRegex);\n            if (match) {\n                const sourceStepId = match[1];\n                const requestedFieldName = match[2];\n\n                // Security: Validate sourceStepId and requestedFieldName\n                // sourceStepId should be an existing key in stepOutputs\n                if (!Object.prototype.hasOwnProperty.call(stepOutputs, sourceStepId)) {\n                    throw new Error(`Unresolved reference: Step ID '${sourceStepId}' not found in outputs (referenced by step ${currentStepIdForLog}).`);\n                }\n                const allowedFieldNames = ['result_data', 'processed_result_data'];\n                if (!allowedFieldNames.includes(requestedFieldName)) {\n                    throw new Error(`Unresolved reference: Invalid field name '${requestedFieldName}' for step '${sourceStepId}' (referenced by step ${currentStepIdForLog}).`);\n                }\n\n                // Strict check for COMPLETED status\n                // eslint-disable-next-line security/detect-object-injection -- sourceStepId is validated by hasOwnProperty call above. Accessing .status property.\n                if (stepOutputs[sourceStepId].status !== \"COMPLETED\") {\n                // eslint-disable-next-line security/detect-object-injection -- sourceStepId is validated by hasOwnProperty call above. Accessing .status property for error message.\n                     throw new Error(`Referenced step '${sourceStepId}' did not complete successfully. Status: ${stepOutputs[sourceStepId].status} (referenced by step ${currentStepIdForLog}). Cannot use its output.`);\n                }\n\n                let actualFieldName = requestedFieldName;\n                // eslint-disable-next-line security/detect-object-injection -- sourceStepId is validated by hasOwnProperty, actualFieldName is from allowed list or checked with hasOwnProperty.\n                let resolvedValue = stepOutputs[sourceStepId][actualFieldName];\n\n                // Fallback logic for processed_result_data\n                if (requestedFieldName === 'processed_result_data' && (resolvedValue === undefined || resolvedValue === null)) {\n                    // Security: Use Object.prototype.hasOwnProperty.call to avoid prototype pollution.\n                    if (Object.prototype.hasOwnProperty.call(stepOutputs[sourceStepId], 'result_data')) { // Check if result_data actually exists\n                        console.warn(`PlanExecutor._resolveOutputReferences: Field 'processed_result_data' for step '${sourceStepId}' is null or undefined. Falling back to 'result_data' (referenced by step ${currentStepIdForLog}).`);\n                        actualFieldName = 'result_data';\n                        // eslint-disable-next-line security/detect-object-injection -- sourceStepId and actualFieldName (now 'result_data') are validated.\n                        resolvedValue = stepOutputs[sourceStepId][actualFieldName];\n                    } else {\n                        // If even result_data doesn't exist (should be rare for completed steps), this is an issue.\n                         console.warn(`PlanExecutor._resolveOutputReferences: Field 'processed_result_data' for step '${sourceStepId}' is null/undefined, and fallback 'result_data' also does not exist (referenced by step ${currentStepIdForLog}).`);\n                        // Keep resolvedValue as is (null/undefined) or throw error based on strictness desired.\n                        // For now, let it pass as null/undefined if both are missing.\n                    }\n                }\n\n                // Check if the (potentially fallback) fieldName actually exists in the output\n                // Security: Use Object.prototype.hasOwnProperty.call to avoid prototype pollution.\n                // eslint-disable-next-line security/detect-object-injection -- sourceStepId is validated by hasOwnProperty. Using stepOutputs[sourceStepId] as context for hasOwnProperty check on actualFieldName.\n                if (!Object.prototype.hasOwnProperty.call(stepOutputs[sourceStepId], actualFieldName)) {\n                     throw new Error(`Unresolved reference: Field '${actualFieldName}' not found in output of step '${sourceStepId}' (referenced by step ${currentStepIdForLog}).`);\n                }\n\n                return resolvedValue;\n            }\n            return data; // Not a reference\n        } else if (Array.isArray(data)) {\n            // Use Promise.all for concurrent async resolution of array items\n            const resolvedArray = await Promise.all(data.map(item => this._resolveOutputReferences(item, stepOutputs, currentStepIdForLog)));\n            return resolvedArray;\n        } else if (typeof data === 'object' && data !== null) {\n            const newData = {};\n            for (const key in data) {\n                // eslint-disable-next-line security/detect-object-injection -- 'key' is from 'data' (part of sub_task_input from plan). 'newData' is a fresh, local object, limiting impact. Plan generation should ensure 'key' is not malicious (e.g., '__proto__').\n                newData[key] = await this._resolveOutputReferences(data[key], stepOutputs, currentStepIdForLog);\n            }\n            return newData;\n        }\n        return data;\n    }\n\n    _createJournalEntry(type, message, details = {}, source = \"PlanExecutor\") {\n        return {\n            timestamp: new Date().toISOString(),\n            type,\n            source,\n            message,\n            details\n        };\n    }\n\n    async _summarizeStepData(dataToSummarize, userTaskString, narrativeStep, subTaskId, parentTaskId) { // Removed journalEntries\n        const MAX_DATA_LENGTH = 1000;\n        let dataString;\n\n        if (typeof dataToSummarize === 'string') {\n            dataString = dataToSummarize;\n        } else {\n            try {\n                dataString = JSON.stringify(dataToSummarize);\n            } catch (e) {\n                console.warn(`PlanExecutor.summarizeDataWithLLM: Could not stringify data for step \"${narrativeStep}\". Using raw data type. Error: ${e.message}`);\n                return dataToSummarize; // Return original data if stringification fails\n            }\n        }\n\n        if (dataString.length > MAX_DATA_LENGTH) {\n            // Journaling for summarization START/SUCCESS/FAILURE will be handled in executePlan\n            console.log(`PlanExecutor._summarizeStepData: Data for step \"${narrativeStep}\" (SubTaskID: ${subTaskId}) is too long (${dataString.length} chars), attempting summarization.`);\n            const summarizationPrompt = `The original user task was: \"${userTaskString}\".\nA step in the execution plan, described as \"${narrativeStep}\", produced the following data:\n---\n${dataString.substring(0, MAX_DATA_LENGTH)}... (data truncated for this prompt if originally longer)\n---\nPlease summarize this data concisely, keeping in mind its relevance to the original user task and the step description. The summary should be a string, suitable for inclusion as context for a final answer synthesis. Focus on extracting key information and outcomes. Provide only the summary text.`;\n            try {\n                // const summary = await this.llmService(summarizationPrompt); // OLD\n                const summary = await this.aiService.generateText(summarizationPrompt, { model: (this.aiService.baseConfig && this.aiService.baseConfig.summarizationModel) || 'gpt-3.5-turbo' }); // NEW\n                if (typeof summary === 'string' && summary.trim() !== \"\") {\n                    console.log(`PlanExecutor._summarizeStepData: Summarization successful for step \"${narrativeStep}\" (SubTaskID: ${subTaskId}).`);\n                    return summary;\n                } else {\n                    console.warn(`PlanExecutor._summarizeStepData: LLM returned empty or non-string summary for step \"${narrativeStep}\" (SubTaskID: ${subTaskId}). Original data (or its beginning) will be used.`);\n                    return dataString.substring(0, MAX_DATA_LENGTH) + (dataString.length > MAX_DATA_LENGTH ? \"... (original data was too long and summarization failed)\" : \"\");\n                }\n            } catch (error) {\n                console.error(`PlanExecutor._summarizeStepData: Error during summarization for step \"${narrativeStep}\" (SubTaskID: ${subTaskId}): ${error.message}`);\n                // Return original (truncated) data in case of error, actual error logging will be in executePlan\n                return dataString.substring(0, MAX_DATA_LENGTH) + (dataString.length > MAX_DATA_LENGTH ? \"... (original data was too long, summarization error occurred)\" : \"\");\n            }\n        }\n        return dataToSummarize;\n    }\n\n    // Signature updated to accept resolvedSubTaskInput\n    async _handleExploreSearchResults(sub_task_id, subTaskDefinition, resolvedSubTaskInput, executionContext, _parentTaskId) {\n        console.log(`PlanExecutor: Handling special step ExploreSearchResults: \"${subTaskDefinition.narrative_step}\" (SubTaskID: ${sub_task_id}, StepID: ${subTaskDefinition.stepId})`);\n\n        const originalSubTaskInput = subTaskDefinition.sub_task_input;\n        const pageProcessingErrors = []; // Initialize array for partial errors\n\n        let previousSearchResults = null;\n        const searchResultsInput = resolvedSubTaskInput?.searchResults;\n\n        if (searchResultsInput && Array.isArray(searchResultsInput)) {\n            previousSearchResults = searchResultsInput;\n        } else {\n            for (let k = executionContext.length - 1; k >= 0; k--) {\n                // eslint-disable-next-line security/detect-object-injection -- k is a controlled integer index. Accessing known properties.\n                const potentialResults = executionContext[k].processed_result_data || executionContext[k].raw_result_data;\n                // eslint-disable-next-line security/detect-object-injection -- k is a controlled integer index. Accessing known properties.\n                if (executionContext[k].tool_name === \"WebSearchTool\" && executionContext[k].status === \"COMPLETED\" && potentialResults) {\n                    if (Array.isArray(potentialResults)) {\n                        previousSearchResults = potentialResults;\n                    } else if (typeof potentialResults === 'object' && Array.isArray(potentialResults.result)) {\n                        previousSearchResults = potentialResults.result;\n                    }\n                    break;\n                }\n            }\n        }\n\n        if (!previousSearchResults || !Array.isArray(previousSearchResults) || previousSearchResults.length === 0) {\n            console.warn(`PlanExecutor.ExploreSearchResults (StepID: ${subTaskDefinition.stepId}): No valid search results found.`);\n            return {\n                sub_task_id: sub_task_id,\n                stepId: subTaskDefinition.stepId,\n                narrative_step: subTaskDefinition.narrative_step,\n                tool_name: \"ExploreSearchResults\",\n                assigned_agent_role: \"Orchestrator\",\n                sub_task_input: originalSubTaskInput,\n                status: \"COMPLETED\",\n                result_data: \"No search results available to explore or results format was incompatible.\",\n                partial_errors: pageProcessingErrors,\n                error_details: { message: \"No valid search results found to explore.\" }\n            };\n        }\n\n        const pagesToExplore = resolvedSubTaskInput?.pagesToExplore || 2;\n        const linksToRead = previousSearchResults.slice(0, pagesToExplore)\n            .map(item => item && item.link)\n            .filter(link => typeof link === 'string' && link.trim() !== '');\n\n        if (linksToRead.length === 0) {\n            return {\n                sub_task_id: sub_task_id,\n                stepId: subTaskDefinition.stepId,\n                narrative_step: subTaskDefinition.narrative_step,\n                tool_name: \"ExploreSearchResults\",\n                assigned_agent_role: \"Orchestrator\",\n                sub_task_input: originalSubTaskInput,\n                status: \"COMPLETED\",\n                result_data: \"No valid links found in search results to explore.\",\n                partial_errors: pageProcessingErrors,\n                error_details: { message: \"No valid links found in search results to explore.\" }\n            };\n        }\n\n        let aggregatedContent = \"\";\n        const webpageReader = this.tools.ReadWebpageTool || new ReadWebpageTool();\n\n        for (const url of linksToRead) {\n            try {\n                console.log(`PlanExecutor._handleExploreSearchResults: Reading URL - ${url} for SubTaskID: ${sub_task_id}, StepID: ${subTaskDefinition.stepId}`);\n                const readResult = await webpageReader.execute({ url });\n                if (readResult.error) {\n                    const errorDetail = { url: url, errorMessage: readResult.error };\n                    pageProcessingErrors.push(errorDetail);\n                    aggregatedContent += `Error reading ${url}: ${readResult.error}\\n---\\n`;\n                } else if (readResult.result) {\n                    aggregatedContent += `Content from ${url}:\\n${readResult.result}\\n---\\n`;\n                }\n            } catch (e) {\n                const errorDetail = { url: url, errorMessage: e.message };\n                pageProcessingErrors.push(errorDetail);\n                aggregatedContent += `Exception while reading ${url}: ${e.message}\\n---\\n`;\n            }\n        }\n\n        const finalErrorDetails = pageProcessingErrors.length > 0\n            ? { message: `Encountered ${pageProcessingErrors.length} error(s) while processing URLs. See partial_errors for details.` }\n            : null;\n\n        return {\n            sub_task_id: sub_task_id,\n            stepId: subTaskDefinition.stepId,\n            narrative_step: subTaskDefinition.narrative_step,\n            tool_name: \"ExploreSearchResults\",\n            assigned_agent_role: \"Orchestrator\",\n            sub_task_input: originalSubTaskInput,\n            status: \"COMPLETED\", // Step itself completed, even if some pages failed\n            result_data: aggregatedContent.trim() || \"No content could be fetched from the explored pages.\",\n            partial_errors: pageProcessingErrors,\n            error_details: finalErrorDetails\n        };\n    }\n\n    // Signature updated to accept resolvedSubTaskInput, method renamed\n    async _handleLLMStepExecutor(sub_task_id, subTaskDefinition, resolvedSubTaskInput, executionContext, _parentTaskId) { // eslint-disable-line no-unused-vars\n        console.log(`PlanExecutor: Handling special step LLMStepExecutor: \"${subTaskDefinition.narrative_step}\" (SubTaskID: ${sub_task_id}, StepID: ${subTaskDefinition.stepId})`);\n\n        const originalSubTaskInput = subTaskDefinition.sub_task_input;\n        let promptInput = resolvedSubTaskInput?.prompt; // Can be string or array (for chat)\n        const promptTemplate = resolvedSubTaskInput?.prompt_template;\n        const promptParams = resolvedSubTaskInput?.prompt_params || {};\n        const messages = resolvedSubTaskInput?.messages; // For direct chat message input\n\n        if (messages && Array.isArray(messages)) {\n            promptInput = messages; // Use messages array directly if provided\n        } else if (promptTemplate) {\n            promptInput = promptTemplate;\n            for (const key in promptParams) {\n                // Security: Ensure only own properties of promptParams are accessed.\n                if (Object.prototype.hasOwnProperty.call(promptParams, key)) {\n                    const sanitizedKey = escapeRegExp(key); // Sanitize key for RegExp\n                    const placeholder = new RegExp(`{{\\\\s*${sanitizedKey}\\\\s*}}`, 'g'); // eslint-disable-line security/detect-non-literal-regexp\n                    // eslint-disable-next-line security/detect-object-injection -- 'key' is from 'promptParams' own properties, checked by hasOwnProperty. Value used for template filling.\n                    let valueToInject = promptParams[key];\n                    if (valueToInject === \"{previous_step_output}\") {\n                        if (executionContext.length > 0) {\n                        // eslint-disable-next-line security/detect-object-injection -- executionContext is an array, accessing last element with known properties.\n                        const lastStepOutput = executionContext[executionContext.length - 1].processed_result_data || executionContext[executionContext.length - 1].raw_result_data || \"\";\n                        valueToInject = typeof lastStepOutput === 'string' ? lastStepOutput : JSON.stringify(lastStepOutput);\n                    } else {\n                        valueToInject = \"No data from previous steps.\";\n                    }\n                }\n                promptInput = promptInput.replace(placeholder, String(valueToInject));\n              } // Closing for: if (Object.prototype.hasOwnProperty.call(promptParams, key))\n            } // Closing for: for (const key in promptParams)\n\n            // Fallback for {{previous_step_output}} should be applied after all other placeholders are processed\n            if (promptInput.includes(\"{{previous_step_output}}\")) { \n                if (executionContext.length > 0) {\n                    const lastStepOutput = executionContext[executionContext.length - 1].processed_result_data || executionContext[executionContext.length - 1].raw_result_data || \"\";\n                    promptInput = promptInput.replace(new RegExp(\"{{\\\\s*previous_step_output\\\\s*}}\", 'g'), typeof lastStepOutput === 'string' ? lastStepOutput : JSON.stringify(lastStepOutput));\n                } else { // This else is for the inner if (executionContext.length > 0)\n                    promptInput = promptInput.replace(new RegExp(\"{{\\\\s*previous_step_output\\\\s*}}\", 'g'), \"No data from previous steps.\");\n                }\n            }\n        } // Closing for: else if (promptTemplate)\n        // This else if correctly follows the `else if (promptTemplate)`\n        else if (typeof promptInput !== 'string' && !Array.isArray(promptInput)) { \n             promptInput = \"\";\n        }\n\n        // Legacy support for data_from_previous_step if no other prompt/message source\n        if ((!promptInput || (typeof promptInput === 'string' && !promptInput.trim())) && \n            !Array.isArray(promptInput) && \n            resolvedSubTaskInput?.data_from_previous_step === true) {\n            if (executionContext.length > 0) {\n                // eslint-disable-next-line security/detect-object-injection -- executionContext is an array, accessing last element with known properties.\n                const lastStepOutput = executionContext[executionContext.length - 1].processed_result_data || executionContext[executionContext.length - 1].raw_result_data || \"\";\n                promptInput = typeof lastStepOutput === 'string' ? lastStepOutput : JSON.stringify(lastStepOutput);\n            } else {\n                promptInput = \"No data from previous steps to use as prompt.\";\n            }\n        }\n\n        if ((typeof promptInput === 'string' && !promptInput.trim()) || (Array.isArray(promptInput) && promptInput.length === 0)) {\n             return { sub_task_id: sub_task_id, stepId: subTaskDefinition.stepId, narrative_step: subTaskDefinition.narrative_step, tool_name: \"LLMStepExecutor\", assigned_agent_role: \"Orchestrator\", sub_task_input: originalSubTaskInput, status: \"FAILED\", error_details: { message: \"Prompt or messages are empty or invalid for LLMStepExecutor after resolving inputs.\" } };\n        }\n\n        try {\n            let resultData;\n            const stepModel = resolvedSubTaskInput?.model || (this.aiService.baseConfig && this.aiService.baseConfig.defaultLLMStepModel) || 'gpt-3.5-turbo';\n            const stepParams = { model: stepModel };\n            // eslint-disable-next-line security/detect-object-injection -- resolvedSubTaskInput is from plan data, assigning known 'temperature' property to a fresh 'stepParams' object.\n            if (resolvedSubTaskInput?.temperature !== undefined) stepParams.temperature = resolvedSubTaskInput.temperature;\n            // eslint-disable-next-line security/detect-object-injection -- resolvedSubTaskInput is from plan data, assigning known 'maxTokens' property to a fresh 'stepParams' object.\n            if (resolvedSubTaskInput?.maxTokens !== undefined) stepParams.maxTokens = resolvedSubTaskInput.maxTokens;\n\n            if (Array.isArray(promptInput)) {\n                const isValidMessages = promptInput.every(m => typeof m.role === 'string' && typeof m.content === 'string');\n                if (!isValidMessages) throw new Error(\"Invalid message structure for LLMStepExecutor with chat input. Each message must have role and content as strings.\");\n                resultData = await this.aiService.completeChat(promptInput, stepParams);\n            } else if (typeof promptInput === 'string') {\n                resultData = await this.aiService.generateText(promptInput, stepParams);\n            } else {\n                throw new Error(\"Invalid promptInput type for LLMStepExecutor. Must be a string or an array of chat messages.\");\n            }\n            return { sub_task_id: sub_task_id, stepId: subTaskDefinition.stepId, narrative_step: subTaskDefinition.narrative_step, tool_name: \"LLMStepExecutor\", assigned_agent_role: \"Orchestrator\", sub_task_input: originalSubTaskInput, status: \"COMPLETED\", result_data: resultData, error_details: null };\n        } catch (e) {\n            return { sub_task_id: sub_task_id, stepId: subTaskDefinition.stepId, narrative_step: subTaskDefinition.narrative_step, tool_name: \"LLMStepExecutor\", assigned_agent_role: \"Orchestrator\", sub_task_input: originalSubTaskInput, status: \"FAILED\", error_details: { message: e.message } };\n        }\n    }\n\n    async executePlan(planStages, parentTaskId, userTaskString) {\n        const stepOutputs = {}; // Initialize stepOutputs map\n        const journalEntries = [];\n        const executionContext = [];\n        const collectedKeyFindings = [];\n        const collectedErrors = [];\n        let overallSuccess = true;\n        let finalAnswerOutput = null;\n        let finalAnswerWasSynthesized = false;\n        let failedStepDetails = null; // Initialize failedStepDetails\n\n        journalEntries.push(this._createJournalEntry(\n            \"PLAN_EXECUTION_START\",\n            `Starting execution of plan for ParentTaskID: ${parentTaskId}`,\n            { parentTaskId, stageCount: planStages.length }\n        ));\n\n        for (let i = 0; i < planStages.length; i++) {\n            const currentStageTaskDefinitions = planStages[i];\n            const stageIndex = i + 1;\n            journalEntries.push(this._createJournalEntry(\n                \"EXECUTION_STAGE_START\",\n                `Starting Stage ${stageIndex}/${planStages.length}`,\n                { parentTaskId, stageIndex, stageTaskCount: currentStageTaskDefinitions.length }\n            ));\n            console.log(`PlanExecutor: Starting Stage ${stageIndex}/${planStages.length} with ${currentStageTaskDefinitions.length} sub-task(s).`);\n\n            const stageSubTaskPromises = [];\n\n            for (const subTaskDefinition of currentStageTaskDefinitions) {\n                const stepNarrative = subTaskDefinition.narrative_step;\n                const stepId = subTaskDefinition.stepId; // Essential for logging and output tracking\n\n                let resolvedSubTaskInput;\n                try {\n                    // Deep copy original input before resolving, to keep original for contextEntry\n                    const originalInputCopy = JSON.parse(JSON.stringify(subTaskDefinition.sub_task_input));\n                    resolvedSubTaskInput = this._resolveOutputReferences(originalInputCopy, stepOutputs, stepId);\n                } catch (resolutionError) {\n                    console.error(`PlanExecutor: Error resolving output references for stepId '${stepId}': ${resolutionError.message}`);\n                    journalEntries.push(this._createJournalEntry(\n                        \"EXECUTION_STEP_PREPARATION_FAILED\",\n                        `Failed to resolve output references for step: ${stepNarrative} (StepID: ${stepId})`,\n                        { parentTaskId, stageIndex, stepId, narrativeStep: stepNarrative, error: resolutionError.message }\n                    ));\n                    stageSubTaskPromises.push(Promise.resolve({\n                        sub_task_id: uuidv4(), // Generate a sub_task_id for this failure point\n                        stepId: stepId,\n                        narrative_step: stepNarrative,\n                        tool_name: subTaskDefinition.tool_name,\n                        assigned_agent_role: subTaskDefinition.assigned_agent_role,\n                        sub_task_input: subTaskDefinition.sub_task_input, // original input\n                        status: \"FAILED\",\n                        error_details: { message: `Output reference resolution failed: ${resolutionError.message}` }\n                    }));\n                    continue; // Skip to next task in stage\n                }\n\n                // subTaskInputForLog should ideally be the resolved one for better debugging of what the tool *actually* received.\n                // However, the original with @-references is also useful. For now, log original.\n                const subTaskInputForLog = { ...subTaskDefinition.sub_task_input };\n\n\n                if (subTaskDefinition.assigned_agent_role === \"Orchestrator\") {\n                    const sub_task_id_for_orchestrator_step = uuidv4();\n                    journalEntries.push(this._createJournalEntry(\n                        \"EXECUTION_STEP_ORCHESTRATOR_START\",\n                        `Orchestrator starting special step: ${stepNarrative} (StepID: ${stepId})`,\n                        { parentTaskId, stageIndex, subTaskId: sub_task_id_for_orchestrator_step, stepId, narrativeStep: stepNarrative, toolName: subTaskDefinition.tool_name, subTaskInput: subTaskInputForLog }\n                    ));\n                    if (subTaskDefinition.tool_name === \"ExploreSearchResults\") {\n                        // Pass resolvedSubTaskInput and subTaskDefinition\n                        stageSubTaskPromises.push(this._handleExploreSearchResults(sub_task_id_for_orchestrator_step, subTaskDefinition, resolvedSubTaskInput, executionContext, parentTaskId));\n                    } else if (subTaskDefinition.tool_name === \"LLMStepExecutor\") { // Changed from GeminiStepExecutor\n                        // Pass resolvedSubTaskInput and subTaskDefinition\n                        stageSubTaskPromises.push(this._handleLLMStepExecutor(sub_task_id_for_orchestrator_step, subTaskDefinition, resolvedSubTaskInput, executionContext, parentTaskId)); // Renamed method\n                    } else if (subTaskDefinition.tool_name === \"FileSystemTool\" || subTaskDefinition.tool_name === \"FileDownloaderTool\") {\n                        const toolPromise = (async () => {\n                            let tool;\n                            const taskWorkspaceDir = path.join(this.savedTasksBaseDir, parentTaskId, 'workspace');\n                            try {\n                                // eslint-disable-next-line security/detect-non-literal-fs-filename -- taskWorkspaceDir is constructed from base path and system-generated parentTaskId.\n                                await fsp.mkdir(taskWorkspaceDir, { recursive: true });\n                                if (subTaskDefinition.tool_name === \"FileSystemTool\") {\n                                    tool = new FileSystemTool(taskWorkspaceDir);\n                                } else {\n                                    tool = new FileDownloaderTool(taskWorkspaceDir);\n                                }\n                                // Use resolvedSubTaskInput for operations\n                                const operation = resolvedSubTaskInput.operation;\n                                const opParams = resolvedSubTaskInput.params;\n\n                                // Security: Validate the operation name before attempting to call it.\n                                const allowedOperations = Object.getOwnPropertyNames(Object.getPrototypeOf(tool)).filter(prop => typeof tool[prop] === 'function' && !prop.startsWith('_') && prop !== 'constructor');\n                                if (typeof tool[operation] !== 'function' || !allowedOperations.includes(operation) ) {\n                                    throw new Error(`Operation '${operation}' not found or not allowed on tool '${subTaskDefinition.tool_name}'.`);\n                                }\n\n                                // eslint-disable-next-line security/detect-object-injection -- 'operation' is validated against an allowed list derived from tool's prototype methods.\n                                const toolResult = await tool[operation](opParams);\n                                return {\n                                    sub_task_id: sub_task_id_for_orchestrator_step,\n                                    stepId: stepId,\n                                    narrative_step: stepNarrative,\n                                    tool_name: subTaskDefinition.tool_name,\n                                    assigned_agent_role: \"Orchestrator\",\n                                    sub_task_input: subTaskDefinition.sub_task_input, // original input\n                                    status: toolResult.error ? \"FAILED\" : \"COMPLETED\",\n                                    result_data: toolResult.result,\n                                    error_details: toolResult.error ? { message: toolResult.error } : null\n                                };\n                            } catch (err) {\n                                // eslint-disable-next-line security/detect-object-injection -- resolvedSubTaskInput.operation is from plan data, used here for logging purposes only.\n                                console.error(`PlanExecutor: Error executing Orchestrator tool ${subTaskDefinition.tool_name}, operation ${resolvedSubTaskInput.operation} (StepID: ${stepId}): ${err.message}`);\n                                return {\n                                    sub_task_id: sub_task_id_for_orchestrator_step,\n                                    stepId: stepId,\n                                    narrative_step: stepNarrative,\n                                    tool_name: subTaskDefinition.tool_name,\n                                    assigned_agent_role: \"Orchestrator\",\n                                    sub_task_input: subTaskDefinition.sub_task_input, // original input\n                                    status: \"FAILED\",\n                                    error_details: { message: err.message }\n                                };\n                            }\n                        })();\n                        stageSubTaskPromises.push(toolPromise);\n                    } else {\n                         console.error(`PlanExecutor: Unknown tool '${subTaskDefinition.tool_name}' for Orchestrator role. Step: \"${stepNarrative}\" (StepID: ${stepId})`);\n                         stageSubTaskPromises.push(Promise.resolve({\n                            sub_task_id: sub_task_id_for_orchestrator_step,\n                            stepId: stepId,\n                            narrative_step: stepNarrative,\n                            tool_name: subTaskDefinition.tool_name,\n                            assigned_agent_role: \"Orchestrator\",\n                            sub_task_input: subTaskDefinition.sub_task_input, // original input\n                            status: \"FAILED\",\n                            error_details: { message: `Unknown Orchestrator tool: ${subTaskDefinition.tool_name}` }\n                        }));\n                    }\n                } else {\n                    const sub_task_id = uuidv4();\n                    // Use resolvedSubTaskInput for the task message\n                    const taskMessage = { sub_task_id, parent_task_id: parentTaskId, assigned_agent_role: subTaskDefinition.assigned_agent_role, tool_name: subTaskDefinition.tool_name, sub_task_input: resolvedSubTaskInput, narrative_step: stepNarrative, stepId: stepId };\n\n                    journalEntries.push(this._createJournalEntry(\n                        \"EXECUTION_STEP_DISPATCHED\",\n                        `Dispatching step: ${stepNarrative} (SubTaskID: ${sub_task_id}, StepID: ${stepId}) to agent ${taskMessage.assigned_agent_role}`,\n                        { parentTaskId, stageIndex, subTaskId: sub_task_id, stepId, narrativeStep: stepNarrative, toolName: taskMessage.tool_name, agentRole: taskMessage.assigned_agent_role, subTaskInputForLog }\n                    ));\n                    this.subTaskQueue.enqueueTask(taskMessage);\n                    console.log(`PlanExecutor: Dispatched sub-task ${sub_task_id} (StepID: ${stepId}) for role ${taskMessage.assigned_agent_role} - Step: \"${stepNarrative}\" for Stage ${stageIndex}`);\n\n                    const subTaskPromise = new Promise((resolve) => {\n                        this.resultsQueue.subscribeOnce(parentTaskId, (error, resultMsg) => {\n                            const resultDetails = { parentTaskId, stageIndex, subTaskId: sub_task_id, narrativeStep: stepNarrative };\n                            if (error) {\n                                journalEntries.push(this._createJournalEntry(\"EXECUTION_STEP_RESULT_ERROR\", `Error or timeout for SubTaskID: ${sub_task_id}`, { ...resultDetails, error: error.message }));\n                                console.error(`PlanExecutor: Error or timeout waiting for result of sub_task_id ${sub_task_id} (Stage ${stageIndex}):`, error.message);\n                                resolve({ sub_task_id, narrative_step: stepNarrative, tool_name: taskMessage.tool_name, sub_task_input: taskMessage.sub_task_input, assigned_agent_role: taskMessage.assigned_agent_role, status: \"FAILED\", error_details: { message: error.message } });\n                            } else if (resultMsg) {\n                                const resultDataPreview = typeof resultMsg.result_data === 'string' ? resultMsg.result_data.substring(0,100) + '...' : String(resultMsg.result_data);\n                                journalEntries.push(this._createJournalEntry(\"EXECUTION_STEP_RESULT_RECEIVED\", `Result received for SubTaskID: ${sub_task_id}, Status: ${resultMsg.status}`, { ...resultDetails, status: resultMsg.status, agentRole: resultMsg.worker_agent_role, resultDataPreview, errorDetails: resultMsg.error_details }));\n                                if (resultMsg.sub_task_id === sub_task_id) {\n                                    console.log(`PlanExecutor: Received result for sub_task_id ${sub_task_id} (Stage ${stageIndex}). Status: ${resultMsg.status}`);\n                    resolve({\n                        sub_task_id,\n                        stepId: taskMessage.stepId, // Ensure stepId is part of the resolved object\n                        narrative_step: stepNarrative,\n                        tool_name: taskMessage.tool_name,\n                        sub_task_input: subTaskDefinition.sub_task_input, // original input for context\n                        assigned_agent_role: taskMessage.assigned_agent_role,\n                        status: resultMsg.status,\n                        result_data: resultMsg.result_data,\n                        error_details: resultMsg.error_details\n                    });\n                                } else {\n                    const errorMessage = `Critical - Mismatched sub_task_id. Expected ${sub_task_id}, got ${resultMsg.sub_task_id} (StepID: ${taskMessage.stepId})`;\n                    journalEntries.push(this._createJournalEntry(\"EXECUTION_STEP_RESULT_ERROR\", errorMessage, { ...resultDetails, stepId: taskMessage.stepId, expectedSubTaskId: sub_task_id, receivedSubTaskId: resultMsg.sub_task_id }));\n                                    console.error(`PlanExecutor: ${errorMessage} for parent_task_id ${parentTaskId} (Stage ${stageIndex}).`);\n                    resolve({\n                        sub_task_id,\n                        stepId: taskMessage.stepId,\n                        narrative_step: stepNarrative,\n                        tool_name: taskMessage.tool_name,\n                        sub_task_input: subTaskDefinition.sub_task_input,\n                        assigned_agent_role: taskMessage.assigned_agent_role,\n                        status: \"FAILED\",\n                        error_details: { message: \"Mismatched sub_task_id in result processing.\", details: errorMessage }\n                    });\n                                }\n                            }\n                        }, sub_task_id);\n                    });\n                    stageSubTaskPromises.push(subTaskPromise);\n                }\n            }\n\n            const stageResults = await Promise.all(stageSubTaskPromises);\n            const stageContextEntries = [];\n            let firstFailedStepErrorDetails = null;\n\n            for (let j = 0; j < stageResults.length; j++) {\n                const resultOfSubTask = stageResults[j]; // This now includes stepId\n                const originalSubTaskDef = currentStageTaskDefinitions[j]; // This is the definition from the plan\n\n                const subTaskIdForResult = resultOfSubTask.sub_task_id;\n                const stepIdForResult = resultOfSubTask.stepId || originalSubTaskDef.stepId; // Prefer stepId from result if available (e.g. for internally generated failures)\n\n                let processedData = resultOfSubTask.result_data;\n                const summarizationLogDetails = { parentTaskId, stageIndex, subTaskId: subTaskIdForResult, stepId: stepIdForResult, narrativeStep: resultOfSubTask.narrative_step };\n\n                if (resultOfSubTask.status === \"COMPLETED\" && resultOfSubTask.result_data &&\n                    (resultOfSubTask.assigned_agent_role !== \"Orchestrator\" ||\n                     (resultOfSubTask.assigned_agent_role === \"Orchestrator\" && subTaskDefinition.tool_name === \"ExploreSearchResults\"))) { // eslint-disable-line no-undef\n                    journalEntries.push(this._createJournalEntry(\"EXECUTION_DATA_SUMMARIZATION_START\", `Summarizing data for step: ${resultOfSubTask.narrative_step} (StepID: ${stepIdForResult})`, summarizationLogDetails));\n                    const originalDataForPreview = resultOfSubTask.result_data;\n                    try {\n                        const summary = await this._summarizeStepData(resultOfSubTask.result_data, userTaskString, resultOfSubTask.narrative_step, subTaskIdForResult, parentTaskId);\n                        if (summary !== resultOfSubTask.result_data) {\n                             journalEntries.push(this._createJournalEntry(\"EXECUTION_DATA_SUMMARIZATION_SUCCESS\", `Successfully summarized data for step: ${resultOfSubTask.narrative_step} (StepID: ${stepIdForResult})`, { ...summarizationLogDetails, summarizedDataPreview: String(summary).substring(0,100) + \"...\"}));\n                        }\n                        processedData = summary;\n                    } catch (summarizationError) {\n                        journalEntries.push(this._createJournalEntry(\"EXECUTION_DATA_SUMMARIZATION_FAILED\", `Summarization failed for step: ${resultOfSubTask.narrative_step} (StepID: ${stepIdForResult})`, { ...summarizationLogDetails, errorMessage: summarizationError.message }));\n                         console.error(`PlanExecutor: Error during _summarizeStepData call for SubTaskID ${subTaskIdForResult} (StepID: ${stepIdForResult}): ${summarizationError.message}`);\n                        processedData = originalDataForPreview;\n                    }\n                }\n\n                const contextEntry = {\n                    stepId: stepIdForResult, // Ensure stepId is in contextEntry\n                    narrative_step: resultOfSubTask.narrative_step || originalSubTaskDef.narrative_step,\n                    assigned_agent_role: resultOfSubTask.assigned_agent_role || originalSubTaskDef.assigned_agent_role,\n                    tool_name: resultOfSubTask.tool_name || originalSubTaskDef.tool_name,\n                    sub_task_input: originalSubTaskDef.sub_task_input, // Always store the original input with @-references\n                    status: resultOfSubTask.status,\n                    processed_result_data: processedData,\n                    raw_result_data: resultOfSubTask.result_data,\n                    error_details: resultOfSubTask.error_details,\n                    sub_task_id: subTaskIdForResult\n                };\n                stageContextEntries.push(contextEntry);\n\n                // Populate stepOutputs for reference resolution\n                if (contextEntry.stepId) {\n                    // eslint-disable-next-line security/detect-object-injection -- contextEntry.stepId is a UUID or plan-defined ID. Assigning to stepOutputs map.\n                    stepOutputs[contextEntry.stepId] = {\n                        status: contextEntry.status,\n                        result_data: contextEntry.raw_result_data,\n                        processed_result_data: contextEntry.processed_result_data,\n                        error_details: contextEntry.error_details\n                        // Note: partial_errors from ExploreSearchResults are not stored in stepOutputs directly,\n                        // as they are specific to that tool's execution instance.\n                        // They are processed below to be added to collectedErrors for CWC.\n                    };\n                }\n\n                // Process partial_errors from ExploreSearchResults\n                if (contextEntry.tool_name === \"ExploreSearchResults\" &&\n                    resultOfSubTask.partial_errors &&\n                    resultOfSubTask.partial_errors.length > 0) {\n\n                    journalEntries.push(this._createJournalEntry(\n                        \"EXECUTION_STEP_PARTIAL_ERRORS\",\n                        `Step '${contextEntry.narrative_step}' (Tool: ${contextEntry.tool_name}, StepID: ${contextEntry.stepId}) completed with ${resultOfSubTask.partial_errors.length} partial error(s) while processing URLs.`,\n                        {\n                            parentTaskId,\n                            stageIndex: stageIndex,\n                            subTaskId: contextEntry.sub_task_id,\n                            stepId: contextEntry.stepId,\n                            partialErrorCount: resultOfSubTask.partial_errors.length,\n                            errors: resultOfSubTask.partial_errors\n                        }\n                    ));\n\n                    for (const partialErr of resultOfSubTask.partial_errors) {\n                        const encounteredErrorEntry = {\n                            errorId: uuidv4(),\n                            sourceStepNarrative: `${contextEntry.narrative_step} (processing URL: ${partialErr.url || 'Unknown URL'})`,\n                            sourceToolName: contextEntry.tool_name,\n                            // subToolName: \"ReadWebpageTool\", // Optional: if we want this level of detail\n                            errorMessage: partialErr.errorMessage,\n                            timestamp: new Date().toISOString()\n                        };\n                        collectedErrors.push(encounteredErrorEntry);\n                    }\n                }\n\n\n                const logDetails = { parentTaskId, stageIndex, subTaskId: contextEntry.sub_task_id, stepId: contextEntry.stepId, narrativeStep: contextEntry.narrative_step, toolName: contextEntry.tool_name, agentRole: contextEntry.assigned_agent_role };\n                const dataPreviewForLog = contextEntry.processed_result_data !== undefined ? contextEntry.processed_result_data : contextEntry.raw_result_data;\n\n                if (contextEntry.status === \"COMPLETED\") {\n                    journalEntries.push(this._createJournalEntry(\"EXECUTION_STEP_COMPLETED\", `Step completed: ${contextEntry.narrative_step}`, { ...logDetails, processedResultDataPreview: String(dataPreviewForLog).substring(0, 100) + \"...\" }));\n\n                    // Collect Key Finding for CurrentWorkingContext\n                    const findingData = contextEntry.processed_result_data || contextEntry.raw_result_data;\n                    if (findingData || (typeof findingData === 'boolean' || typeof findingData === 'number')) { // Ensure data is not null/undefined, allow boolean/numbers\n                        let dataToStore = findingData;\n                        const MAX_FINDING_DATA_LENGTH = 500;\n                        if (typeof findingData === 'string' && findingData.length > MAX_FINDING_DATA_LENGTH) {\n                            dataToStore = findingData.substring(0, MAX_FINDING_DATA_LENGTH) + \"...\";\n                        } else if (typeof findingData === 'object') {\n                            // Optionally stringify and truncate objects if they can be very large\n                            // For now, keeping small objects as is.\n                            // dataToStore = JSON.stringify(findingData);\n                            // if (dataToStore.length > MAX_FINDING_DATA_LENGTH) dataToStore = dataToStore.substring(0, MAX_FINDING_DATA_LENGTH) + \"...\";\n                        }\n                        const keyFinding = {\n                            findingId: uuidv4(),\n                            sourceStepNarrative: contextEntry.narrative_step,\n                            sourceToolName: contextEntry.tool_name,\n                            data: dataToStore,\n                            timestamp: new Date().toISOString()\n                        };\n                        collectedKeyFindings.push(keyFinding);\n                    }\n\n                } else if (contextEntry.status === \"FAILED\") {\n                    journalEntries.push(this._createJournalEntry(\"EXECUTION_STEP_FAILED\", `Step failed: ${contextEntry.narrative_step}`, { ...logDetails, errorDetails: contextEntry.error_details }));\n                    if (!firstFailedStepErrorDetails) { // This is the first failure in the stage that we're processing\n                        firstFailedStepErrorDetails = contextEntry.error_details || { message: \"Unknown error in failed step.\" };\n                        // Populate failedStepDetails with comprehensive information\n                        failedStepDetails = {\n                            sub_task_id: contextEntry.sub_task_id,\n                            stepId: contextEntry.stepId, // Add stepId here\n                            narrative_step: contextEntry.narrative_step,\n                            tool_name: contextEntry.tool_name,\n                            assigned_agent_role: contextEntry.assigned_agent_role,\n                            sub_task_input: contextEntry.sub_task_input,\n                            error_details: contextEntry.error_details\n                        };\n                        // Ensure sub_task_id is part of firstFailedStepErrorDetails if it was missing before, for compatibility with existing logging\n                        if (!firstFailedStepErrorDetails.sub_task_id && contextEntry.sub_task_id) { // This sub_task_id is the uuid for the execution instance\n                            firstFailedStepErrorDetails.sub_task_id = contextEntry.sub_task_id;\n                        }\n                         // Add stepId to firstFailedStepErrorDetails as well for consistency if needed elsewhere\n                        if (!firstFailedStepErrorDetails.stepId && contextEntry.stepId) {\n                            firstFailedStepErrorDetails.stepId = contextEntry.stepId;\n                        }\n                    }\n                    // Collect Error for CurrentWorkingContext\n                    if (contextEntry.error_details) {\n                        const encounteredError = {\n                            errorId: uuidv4(), // Add an ID for errors as well\n                            sourceStepNarrative: contextEntry.narrative_step,\n                            sourceToolName: contextEntry.tool_name,\n                            errorMessage: contextEntry.error_details.message || JSON.stringify(contextEntry.error_details),\n                            timestamp: new Date().toISOString()\n                        };\n                        collectedErrors.push(encounteredError);\n                    }\n                }\n            }\n            executionContext.push(...stageContextEntries);\n\n            let stageFailed = false;\n            for (const entry of stageContextEntries) {\n                if (entry.status === \"FAILED\") {\n                    console.error(`PlanExecutor: Sub-task ${entry.sub_task_id} (\"${entry.narrative_step}\") failed in Stage ${stageIndex}. Halting further stages.`);\n                    overallSuccess = false;\n                    stageFailed = true;\n                    break;\n                }\n            }\n\n            if (stageFailed) {\n                const reason = firstFailedStepErrorDetails ?\n                               `Step ${firstFailedStepErrorDetails.sub_task_id || originalSubTaskDef.sub_task_id} (\"${firstFailedStepErrorDetails.narrative_step || originalSubTaskDef.narrative_step}\") failed: ${firstFailedStepErrorDetails.message || 'Unknown error'}` : // eslint-disable-line no-undef\n                               \"A step in the stage failed.\"; // eslint-disable-line no-undef\n                journalEntries.push(this._createJournalEntry(\"EXECUTION_STAGE_FAILED\", `Stage ${stageIndex} failed. Reason: ${reason}. Halting plan execution.`, { parentTaskId, stageIndex, reason: firstFailedStepErrorDetails }));\n                break;\n            } else {\n                journalEntries.push(this._createJournalEntry(\"EXECUTION_STAGE_COMPLETED\", `Stage ${stageIndex} completed successfully.`, { parentTaskId, stageIndex }));\n            }\n            console.log(`PlanExecutor: Stage ${stageIndex} completed successfully.`);\n        }\n\n        journalEntries.push(this._createJournalEntry(\n            overallSuccess ? \"PLAN_EXECUTION_COMPLETED\" : \"PLAN_EXECUTION_FAILED\",\n            `Execution of plan for ParentTaskID: ${parentTaskId} finished. Success: ${overallSuccess}`,\n            { parentTaskId, overallSuccess }\n        ));\n        console.log(`PlanExecutor: Finished processing all stages for parentTaskId: ${parentTaskId}. Overall success: ${overallSuccess}`);\n\n        // Check for pre-synthesized final answer\n        if (overallSuccess && executionContext.length > 0) {\n            // eslint-disable-next-line security/detect-object-injection -- executionContext is an array, accessing last element with known properties.\n            const lastStepContext = executionContext[executionContext.length - 1];\n            // eslint-disable-next-line security/detect-object-injection -- lastStepContext is from executionContext array, accessing known 'status' property.\n            if (lastStepContext.status === \"COMPLETED\" &&\n            // eslint-disable-next-line security/detect-object-injection -- lastStepContext is from executionContext array, accessing known 'assigned_agent_role' property.\n                lastStepContext.assigned_agent_role === \"Orchestrator\" &&\n            // eslint-disable-next-line security/detect-object-injection -- lastStepContext is from executionContext array, accessing known 'tool_name' property.\n                lastStepContext.tool_name === \"LLMStepExecutor\" && // Changed from GeminiStepExecutor\n            // eslint-disable-next-line security/detect-object-injection -- lastStepContext is from executionContext array, accessing known 'sub_task_input' property.\n                lastStepContext.sub_task_input && // original sub_task_input\n            // eslint-disable-next-line security/detect-object-injection -- lastStepContext is from executionContext array, accessing known 'sub_task_input.isFinalAnswer' property.\n                lastStepContext.sub_task_input.isFinalAnswer === true) { // Check on original input\n\n                // eslint-disable-next-line security/detect-object-injection -- lastStepContext is from executionContext array, accessing known properties.\n                finalAnswerOutput = lastStepContext.processed_result_data || lastStepContext.raw_result_data;\n                finalAnswerWasSynthesized = true;\n\n                journalEntries.push(this._createJournalEntry(\n                    \"PLAN_EXECUTOR_FINAL_ANSWER_IDENTIFIED\",\n                    \"Final answer was marked as synthesized by PlanExecutor within a plan step.\",\n                    {\n                        parentTaskId,\n                        stepNarrative: lastStepContext.narrative_step,\n                        subTaskId: lastStepContext.sub_task_id,\n                        stepId: lastStepContext.stepId\n                    }\n                ));\n                console.log(`PlanExecutor: Final answer identified as pre-synthesized by step: \"${lastStepContext.narrative_step}\" (StepID: ${lastStepContext.stepId})`);\n            }\n        }\n\n        return {\n            success: overallSuccess,\n            executionContext,\n            journalEntries,\n            updatesForWorkingContext: {\n                keyFindings: collectedKeyFindings,\n                errorsEncountered: collectedErrors\n            },\n            finalAnswer: finalAnswerOutput,\n            finalAnswerSynthesized: finalAnswerWasSynthesized,\n            failedStepDetails: failedStepDetails // Add the new field here\n        };\n    }\n}\n\nmodule.exports = PlanExecutor;\n","usedDeprecatedRules":[{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]}]