[{"filePath":"/app/core/PlanManager.js","messages":[{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":204,"column":42,"nodeType":"MemberExpression","endLine":204,"endColumn":59},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":204,"column":85,"nodeType":"MemberExpression","endLine":204,"endColumn":102},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":204,"column":119,"nodeType":"MemberExpression","endLine":204,"endColumn":136}],"suppressedMessages":[{"ruleId":"security/detect-object-injection","severity":1,"message":"Function Call Object Injection Sink","line":26,"column":55,"nodeType":"MemberExpression","endLine":26,"endColumn":65,"suppressions":[{"kind":"directive","justification":"'key' is from 'input' (plan data). Function is recursive and performs read-only validation checks."}]},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":48,"column":18,"nodeType":"CallExpression","endLine":48,"endColumn":45,"suppressions":[{"kind":"directive","justification":"templatesDir is a constructor-set base path."}]},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":60,"column":21,"nodeType":"CallExpression","endLine":60,"endColumn":44,"suppressions":[{"kind":"directive","justification":"filePath is constructed from a base path and statically defined filenames."}]},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found readFileSync from package \"fs\" with non literal argument at index 0","line":62,"column":45,"nodeType":"CallExpression","endLine":62,"endColumn":78,"suppressions":[{"kind":"directive","justification":"filePath is constructed from a base path and statically defined filenames."}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Variable Assigned to Object Injection Sink","line":86,"column":44,"nodeType":"MemberExpression","endLine":86,"endColumn":82,"suppressions":[{"kind":"directive","justification":"'placeholder' is a key from 'templateInfo.paramMapping', which is part of statically defined templateDefinitions. Safe."}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":88,"column":39,"nodeType":"MemberExpression","endLine":88,"endColumn":56,"suppressions":[{"kind":"directive","justification":"match is a regex exec array, groupIndex is an integer from static config. Array access by integer is safe."}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":88,"column":59,"nodeType":"MemberExpression","endLine":88,"endColumn":76,"suppressions":[{"kind":"directive","justification":"match is a regex exec array, groupIndex is an integer from static config. Array access by integer is safe."}]},{"ruleId":"security/detect-non-literal-regexp","severity":1,"message":"Found non-literal argument to RegExp Constructor","line":91,"column":83,"nodeType":"NewExpression","endLine":91,"endColumn":129,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// core/PlanManager.js\nconst fs = require('fs');\nconst path = require('path');\nconst { escapeRegExp } = require('../utils/localization'); // Import the escape function\n\n// Helper function moved to module scope\nfunction findInvalidOutputReferences(input, currentStepId, outputRefRegex) {\n    if (typeof input === 'string') {\n        const potentialRefs = input.match(/@{outputs\\.([^}]+)}/g);\n        if (potentialRefs) {\n            for (const ref of potentialRefs) {\n                outputRefRegex.lastIndex = 0; \n                if (!outputRefRegex.test(ref)) {\n                    return `Invalid output reference syntax in: \"${ref}\" for stepId '${currentStepId}'. Must be @{outputs.ID.result_data} or @{outputs.ID.processed_result_data}.`;\n                }\n            }\n        }\n    } else if (Array.isArray(input)) {\n        for (const item of input) {\n            const error = findInvalidOutputReferences(item, currentStepId, outputRefRegex);\n            if (error) return error;\n        }\n    } else if (typeof input === 'object' && input !== null) {\n        for (const key in input) {\n            // eslint-disable-next-line security/detect-object-injection -- 'key' is from 'input' (plan data). Function is recursive and performs read-only validation checks.\n            const error = findInvalidOutputReferences(input[key], currentStepId, outputRefRegex);\n            if (error) return error;\n        }\n    }\n    return null; // No error\n}\n\nclass PlanManager {\n    constructor(aiService, agentCapabilities, planTemplatesPath) { // Changed llmService to aiService\n        this.aiService = aiService; // Changed llmService to aiService\n        this.agentCapabilities = agentCapabilities; // Full capabilities object/array\n        this.planTemplatesPath = planTemplatesPath; // Base path for templates, e.g., path.join(__dirname, '..', 'config', 'plan_templates')\n        this.planTemplates = [];\n        this.loadPlanTemplates();\n    }\n\n    loadPlanTemplates() {\n        // Adapted from OrchestratorAgent.loadPlanTemplates()\n        const templatesDir = this.planTemplatesPath;\n        this.planTemplates = []; // Reset before loading\n        try {\n            // eslint-disable-next-line security/detect-non-literal-fs-filename -- templatesDir is a constructor-set base path.\n            if (!fs.existsSync(templatesDir)) {\n                console.warn(`PlanManager: Plan templates directory not found at ${templatesDir}. No templates loaded.`);\n                return;\n            }\n            // These definitions might need to be passed in or made more generic if they change often\n            const templateDefinitions = [\n                { name: \"weather_query\", fileName: \"weather_query_template.json\", regex: /^(?:what is the )?weather (?:in )?(.+)/i, paramMapping: { CITY_NAME: 1 } },\n                { name: \"calculator\", fileName: \"calculator_template.json\", regex: /^(?:calculate|what is) ([\\d\\s+\\-*/().^%]+)/i, paramMapping: { EXPRESSION: 1 } }\n            ];\n            for (const def of templateDefinitions) {\n                const filePath = path.join(templatesDir, def.fileName);\n                // eslint-disable-next-line security/detect-non-literal-fs-filename -- filePath is constructed from a base path and statically defined filenames.\n                if (fs.existsSync(filePath)) {\n                    // eslint-disable-next-line security/detect-non-literal-fs-filename -- filePath is constructed from a base path and statically defined filenames.\n                    const templateContent = fs.readFileSync(filePath, 'utf8');\n                    this.planTemplates.push({ name: def.name, regex: def.regex, paramMapping: def.paramMapping, template: JSON.parse(templateContent) });\n                    console.log(`PlanManager: Loaded plan template '${def.name}' from ${def.fileName}`);\n                } else {\n                    console.warn(`PlanManager: Plan template file ${def.fileName} not found in ${templatesDir}`);\n                }\n            }\n        } catch (error) {\n            console.error(`PlanManager: Error loading plan templates: ${error.message}`);\n            this.planTemplates = [];\n        }\n    }\n\n    async tryGetPlanFromTemplate(userTaskString) {\n        // Adapted from OrchestratorAgent.tryGetPlanFromTemplate()\n        if (!this.planTemplates || this.planTemplates.length === 0) return null;\n        for (const templateInfo of this.planTemplates) {\n            const match = templateInfo.regex.exec(userTaskString);\n            if (match) {\n                console.log(`PlanManager: Matched plan template '${templateInfo.name}' for task.`);\n                let populatedTemplateString = JSON.stringify(templateInfo.template);\n                for (const placeholder in templateInfo.paramMapping) {\n                    if (Object.prototype.hasOwnProperty.call(templateInfo.paramMapping, placeholder)) {\n                        // eslint-disable-next-line security/detect-object-injection -- 'placeholder' is a key from 'templateInfo.paramMapping', which is part of statically defined templateDefinitions. Safe.\n                        const groupIndex = templateInfo.paramMapping[placeholder];\n                        // eslint-disable-next-line security/detect-object-injection -- match is a regex exec array, groupIndex is an integer from static config. Array access by integer is safe.\n                        const value = match[groupIndex] ? match[groupIndex].trim() : \"\";\n                        // Security: Sanitize placeholder for use in RegExp.\n                        const sanitizedPlaceholder = escapeRegExp(placeholder);\n                        populatedTemplateString = populatedTemplateString.replace(new RegExp(`{{${sanitizedPlaceholder}}}`, 'g'), value); // eslint-disable-line security/detect-non-literal-regexp\n                    }\n                }\n                try {\n                    return JSON.parse(populatedTemplateString);\n                } catch (e) {\n                    console.error(`PlanManager: Error parsing populated template '${templateInfo.name}'. Error: ${e.message}`);\n                    return null;\n                }\n            }\n        }\n        return null;\n    }\n\n    async parseAndValidatePlan(jsonStringResponse, knownAgentRoles, knownToolsByRole) {\n        // Adapted from global parseSubTaskPlanResponse in OrchestratorAgent.js\n        const MAX_RAW_RESPONSE_LENGTH = 500;\n        let cleanedString = jsonStringResponse;\n\n        if (typeof jsonStringResponse !== 'string') {\n            const detailsString = String(jsonStringResponse);\n            const trimmedDetails = detailsString.length > MAX_RAW_RESPONSE_LENGTH ? detailsString.substring(0, MAX_RAW_RESPONSE_LENGTH) + \"...\" : detailsString;\n            return { success: false, message: \"LLM did not return a string response for the plan.\", details: trimmedDetails, stages: [], rawResponse: jsonStringResponse };\n        }\n\n        try {\n            if (cleanedString.startsWith('```json')) {\n                cleanedString = cleanedString.substring(7);\n                if (cleanedString.endsWith('```')) {\n                    cleanedString = cleanedString.slice(0, -3);\n                }\n            }\n            cleanedString = cleanedString.trim();\n            const parsedStages = JSON.parse(cleanedString);\n\n            if (!Array.isArray(parsedStages)) {\n                return { success: false, message: \"LLM plan is not a JSON array of stages.\", rawResponse: cleanedString, stages: [] };\n            }\n            // Allow empty plan for \"unachievable task\" scenario in replanning.\n            // OrchestratorAgent will handle this (e.g., if planStages is empty after this call).\n            if (parsedStages.length === 0 && cleanedString.trim() !== \"[]\") { // check if it's genuinely empty vs bad parse for non-array\n                return { success: false, message: \"LLM plan is empty (no stages), but not an empty array '[]'.\", rawResponse: cleanedString, stages: [] };\n            }\n             if (parsedStages.length === 0 && cleanedString.trim() === \"[]\") {\n                console.log(\"PlanManager: Parsed an empty plan ('[]'). This is treated as a valid plan indicating no actions to take or task unachievable.\");\n                return { success: true, stages: [], rawResponse: cleanedString, isEmptyPlan: true };\n            }\n\n\n            const allStepIds = new Set();\n            let totalSteps = 0;\n            const outputRefRegex = /@{outputs\\.([a-zA-Z0-9_.-]+)\\.(result_data|processed_result_data)}/g; // g for multiple matches in one string\n\n            for (const stage of parsedStages) {\n                if (!Array.isArray(stage)) {\n                    return { success: false, message: \"Invalid stage in plan: not an array.\", rawResponse: cleanedString, stages: [] };\n                }\n                // Allow empty stages within a non-empty plan\n                // if (stage.length === 0) {\n                //     return { success: false, message: \"Invalid stage in plan: stage is empty.\", rawResponse: cleanedString, stages: [] };\n                // }\n                for (const subTask of stage) {\n                    totalSteps++;\n                    if (typeof subTask !== 'object' || subTask === null) {\n                        return { success: false, message: \"Invalid sub-task structure: not an object.\", rawResponse: cleanedString, stages: [] };\n                    }\n\n                    // Validate stepId\n                    if (!subTask.stepId || typeof subTask.stepId !== 'string' || subTask.stepId.trim() === \"\") {\n                        return { success: false, message: `Missing or invalid 'stepId' (must be a non-empty string) in sub-task: ${JSON.stringify(subTask).substring(0,100)}...`, rawResponse: cleanedString, stages: [] };\n                    }\n                    allStepIds.add(subTask.stepId);\n\n                    // Validate narrative_step\n                    if (!subTask.narrative_step || typeof subTask.narrative_step !== 'string' || !subTask.narrative_step.trim()) {\n                        return { success: false, message: `Missing or empty 'narrative_step' for stepId '${subTask.stepId}'.`, rawResponse: cleanedString, stages: [] };\n                    }\n\n                    // Validate assigned_agent_role and tool_name\n                    if (subTask.assigned_agent_role === \"Orchestrator\") {\n                        const allowedOrchestratorTools = [\"ExploreSearchResults\", \"LLMStepExecutor\", \"FileSystemTool\", \"FileDownloaderTool\"]; // Renamed GeminiStepExecutor\n                        if (!allowedOrchestratorTools.includes(subTask.tool_name)) {\n                            return { success: false, message: `Invalid 'tool_name': ${subTask.tool_name} for Orchestrator role (stepId: ${subTask.stepId}). Allowed: ${allowedOrchestratorTools.join(\", \")}.`, rawResponse: cleanedString, stages: [] };\n                        }\n\n                        if (subTask.tool_name === \"LLMStepExecutor\") { // Validation for LLMStepExecutor\n                            if (!subTask.sub_task_input || (typeof subTask.sub_task_input.prompt !== 'string' && typeof subTask.sub_task_input.prompt_template !== 'string' && !Array.isArray(subTask.sub_task_input.messages))) {\n                                return { success: false, message: `'prompt' (string), 'prompt_template' (string), or 'messages' (array) is required in sub_task_input for LLMStepExecutor (stepId: ${subTask.stepId}).`, rawResponse: cleanedString, stages: [] };\n                            }\n                            if (subTask.sub_task_input.model !== undefined && typeof subTask.sub_task_input.model !== 'string') {\n                                return { success: false, message: `'model' in sub_task_input for LLMStepExecutor must be a string if provided (stepId: ${subTask.stepId}).`, rawResponse: cleanedString, stages: [] };\n                            }\n                        } else if (subTask.tool_name === \"FileSystemTool\" || subTask.tool_name === \"FileDownloaderTool\") {\n                            if (!subTask.sub_task_input || typeof subTask.sub_task_input.operation !== 'string') {\n                                return { success: false, message: `'operation' is required in sub_task_input for Orchestrator tool ${subTask.tool_name} (stepId: ${subTask.stepId}).`, rawResponse: cleanedString, stages: [] };\n                            }\n                            if (!subTask.sub_task_input.params || typeof subTask.sub_task_input.params !== 'object') {\n                                return { success: false, message: `'params' object is required in sub_task_input for Orchestrator tool ${subTask.tool_name} (stepId: ${subTask.stepId}).`, rawResponse: cleanedString, stages: [] };\n                            }\n                        }\n\n                        if (subTask.tool_name === \"FileSystemTool\") {\n                            const fsOps = [\"create_file\", \"read_file\", \"append_to_file\", \"list_files\", \"overwrite_file\", \"create_pdf_from_text\"];\n                            if (!fsOps.includes(subTask.sub_task_input.operation)) {\n                                return { success: false, message: `Invalid 'operation': ${subTask.sub_task_input.operation} for FileSystemTool (stepId: ${subTask.stepId}). Allowed: ${fsOps.join(\", \")}`, rawResponse: cleanedString, stages: [] };\n                            }\n                            const opsRequiringStaticFilenameOrDir = {\n                                \"create_file\": [\"filename\"], \"read_file\": [\"filename\"], \"append_to_file\": [\"filename\"],\n                                \"overwrite_file\": [\"filename\"], \"create_pdf_from_text\": [\"filename\"], \"list_files\": [\"directory\"]\n                            };\n                            if (opsRequiringStaticFilenameOrDir[subTask.sub_task_input.operation]) {\n                                const params = subTask.sub_task_input.params;\n                                for (const paramName of opsRequiringStaticFilenameOrDir[subTask.sub_task_input.operation]) {\n                                     if (params[paramName] !== undefined && (typeof params[paramName] !== 'string' || params[paramName].startsWith(\"@{outputs.\"))) {\n                                        return { success: false, message: `'params.${paramName}' must be a string (not an output reference) for FileSystemTool operation '${subTask.sub_task_input.operation}' (stepId: ${subTask.stepId}).`, rawResponse: cleanedString, stages: [] };\n                                    }\n                                }\n                            }\n                             if ((subTask.sub_task_input.operation === \"create_file\" ||\n                                 subTask.sub_task_input.operation === \"read_file\" ||\n                                 subTask.sub_task_input.operation === \"append_to_file\" ||\n                                 subTask.sub_task_input.operation === \"overwrite_file\" ||\n                                 subTask.sub_task_input.operation === \"create_pdf_from_text\") &&\n                                (!subTask.sub_task_input.params || typeof subTask.sub_task_input.params.filename !== 'string')) {\n                                return { success: false, message: `'params.filename' (string) is required for FileSystemTool operation '${subTask.sub_task_input.operation}' (stepId: ${subTask.stepId}).`, rawResponse: cleanedString, stages: [] };\n                            }\n                            if (subTask.sub_task_input.operation === \"create_pdf_from_text\") {\n                                if (!subTask.sub_task_input.params.filename.toLowerCase().endsWith('.pdf')) {\n                                    return { success: false, message: `'params.filename' for 'create_pdf_from_text' must end with '.pdf' (stepId: ${subTask.stepId}).`, rawResponse: cleanedString, stages: [] };\n                                }\n                                if (typeof subTask.sub_task_input.params.text_content !== 'string') {\n                                    return { success: false, message: `'params.text_content' (string or output reference) is required for 'create_pdf_from_text' (stepId: ${subTask.stepId}).`, rawResponse: cleanedString, stages: [] };\n                                }\n                                // ... other PDF params validation ...\n                            }\n                            if ((subTask.sub_task_input.operation === \"create_file\" ||\n                                 subTask.sub_task_input.operation === \"append_to_file\" ||\n                                 subTask.sub_task_input.operation === \"overwrite_file\") &&\n                                (typeof subTask.sub_task_input.params.content !== 'string')\n                               ) {\n                                 if (subTask.sub_task_input.operation !== \"append_to_file\" || subTask.sub_task_input.params.content === undefined) {\n                                     return { success: false, message: `'params.content' (string or output reference) is required for FileSystemTool operation '${subTask.sub_task_input.operation}' (stepId: ${subTask.stepId}).`, rawResponse: cleanedString, stages: [] };\n                                 }\n                            }\n                        }\n                        if (subTask.tool_name === \"FileDownloaderTool\") {\n                            if (subTask.sub_task_input.operation !== \"download_file\") {\n                                return { success: false, message: `Invalid 'operation': ${subTask.sub_task_input.operation} for FileDownloaderTool (stepId: ${subTask.stepId}). Must be 'download_file'.`, rawResponse: cleanedString, stages: [] };\n                            }\n                            if (!subTask.sub_task_input.params || typeof subTask.sub_task_input.params.url !== 'string') {\n                                return { success: false, message: `'params.url' (string or output reference) is required for FileDownloaderTool (stepId: ${subTask.stepId}).`, rawResponse: cleanedString, stages: [] };\n                            }\n                            if (subTask.sub_task_input.params && subTask.sub_task_input.params.filename !== undefined && (typeof subTask.sub_task_input.params.filename !== 'string' || subTask.sub_task_input.params.filename.startsWith(\"@{outputs.\"))) {\n                                return { success: false, message: `'params.filename' if provided, must be a string (not an output reference) for FileDownloaderTool (stepId: ${subTask.stepId}).`, rawResponse: cleanedString, stages: [] };\n                            }\n                        }\n\n                    } else if (!knownAgentRoles.includes(subTask.assigned_agent_role)) {\n                        // eslint-disable-next-line security/detect-object-injection -- subTask.assigned_agent_role is used in a string for an error message, not for property access. Safe.\n                        return { success: false, message: `Invalid or unknown 'assigned_agent_role': ${subTask.assigned_agent_role} for stepId '${subTask.stepId}'.`, rawResponse: cleanedString, stages: [] };\n                    } else { // Worker agent roles\n                        // eslint-disable-next-line security/detect-object-injection -- subTask.assigned_agent_role is validated by knownAgentRoles.includes() check above.\n                        const agentTools = knownToolsByRole[subTask.assigned_agent_role];\n                        if (!subTask.tool_name || typeof subTask.tool_name !== 'string' || !agentTools || !agentTools.includes(subTask.tool_name)) {\n                            // eslint-disable-next-line security/detect-object-injection -- subTask.tool_name and subTask.assigned_agent_role are used in a string for an error message. Safe.\n                            return { success: false, message: `Invalid or unknown 'tool_name': ${subTask.tool_name} for role ${subTask.assigned_agent_role} (stepId: ${subTask.stepId}).`, rawResponse: cleanedString, stages: [] };\n                        }\n                    }\n\n                    if (typeof subTask.sub_task_input !== 'object' || subTask.sub_task_input === null) {\n                        return { success: false, message: `Invalid 'sub_task_input': must be an object for stepId '${subTask.stepId}'.`, rawResponse: cleanedString, stages: [] };\n                    }\n\n                    // Validate output reference syntax within sub_task_input\n                    const refValidationError = findInvalidOutputReferences(subTask.sub_task_input, subTask.stepId, outputRefRegex);\n                    if (refValidationError) {\n                        return { success: false, message: refValidationError, rawResponse: cleanedString, stages: [] };\n                    }\n                }\n            }\n\n            if (totalSteps > 0 && allStepIds.size !== totalSteps) { // Only if there are steps, check for duplicates\n                return { success: false, message: \"Duplicate 'stepId' found in the plan. All stepIds must be unique.\", rawResponse: cleanedString, stages: [] };\n            }\n\n            return { success: true, stages: parsedStages, rawResponse: cleanedString };\n        } catch (e) {\n            const trimmedRawResponse = cleanedString.length > MAX_RAW_RESPONSE_LENGTH ? cleanedString.substring(0, MAX_RAW_RESPONSE_LENGTH) + \"...\" : cleanedString;\n            console.error(\"PlanManager: Error parsing sub-task plan JSON:\", e.message, \"Raw response:\", trimmedRawResponse);\n            return { success: false, message: \"Failed to parse LLM plan: \" + e.message, rawResponse: trimmedRawResponse, stages: [] };\n        }\n    }\n\n    async getPlan(\n        userTaskString,\n        knownAgentRoles,\n        knownToolsByRole,\n        memoryContext = null, // New parameter\n        currentCWC = null,\n        executionContextSoFar = null,\n        failedStepInfo = null,\n        remainingPlanStages = null,\n        isRevision = false,\n        revisionAttemptNumber = 0,\n        latestKeyFindings = [], // New parameter\n        latestErrors = []      // New parameter\n    ) {\n        let initialPromptSection = `User task: '${userTaskString}'.`;\n        if (memoryContext && memoryContext.taskDefinition && memoryContext.taskDefinition !== userTaskString) {\n            initialPromptSection = `Original task definition from memory: \"${memoryContext.taskDefinition}\"\nCurrent user request (if refining or different): \"${userTaskString}\"`;\n        } else if (memoryContext && memoryContext.taskDefinition) {\n            initialPromptSection = `User task (from memory): \"${memoryContext.taskDefinition}\"`;\n        }\n\n        let memoryContextPromptSection = \"\";\n        if (memoryContext) {\n            if (memoryContext.retrievedKeyDecisions && memoryContext.retrievedKeyDecisions.trim() !== \"\") {\n                memoryContextPromptSection += `\n\nPreviously noted key decisions and learnings:\n---\n${memoryContext.retrievedKeyDecisions}\n---`;\n            }\n            if (memoryContext.retrievedCwcSnapshot && Object.keys(memoryContext.retrievedCwcSnapshot).length > 0) {\n                const cwcSnap = memoryContext.retrievedCwcSnapshot;\n                let cwcSummaryForPrompt = `\n\nSnapshot of relevant prior working context (summary):\n- Prior Progress Summary: ${cwcSnap.summaryOfProgress || 'N/A'}\n- Prior Next Objective: ${cwcSnap.nextObjective || 'N/A'}\n- Prior Key Findings (count): ${(cwcSnap.keyFindings && cwcSnap.keyFindings.length) || 0}\n- Prior Errors Encountered (count): ${(cwcSnap.errorsEncountered && cwcSnap.errorsEncountered.length) || 0}`;\n                memoryContextPromptSection += `${cwcSummaryForPrompt}\n---`;\n            }\n        }\n\n        if (!isRevision) {\n            const templatePlan = await this.tryGetPlanFromTemplate(userTaskString);\n            if (templatePlan) {\n                if (Array.isArray(templatePlan) && templatePlan.every(stage => Array.isArray(stage))) {\n                    return { success: true, plan: templatePlan, source: \"template\", rawResponse: null };\n                } else {\n                    console.error(\"PlanManager: Template plan is not in the expected format (array of stages). Falling back to LLM.\");\n                }\n            }\n            console.log(\"PlanManager: No valid matching template found or template was invalid, proceeding with LLM-based planning for initial plan.\");\n        } else {\n            console.log(`PlanManager: Proceeding with LLM-based replanning. Attempt: ${revisionAttemptNumber}`);\n        }\n\n        let formattedAgentCapabilitiesString = \"\";\n        if (!this.agentCapabilities || this.agentCapabilities.length === 0) {\n            console.error(\"PlanManager: No worker agent capabilities defined. Cannot proceed with LLM planning.\");\n            return { success: false, message: \"Internal Server Error: No worker agent capabilities configured for LLM planning.\", source: \"internal_error\", rawResponse: null };\n        }\n        this.agentCapabilities.forEach(agent => {\n            formattedAgentCapabilitiesString += `Agent Role: ${agent.role}\\n`;\n            formattedAgentCapabilitiesString += `Description: ${agent.description}\\n`;\n            formattedAgentCapabilitiesString += `Tools:\\n`;\n            agent.tools.forEach(tool => {\n                formattedAgentCapabilitiesString += `  - ${tool.name}: ${tool.description}\\n`;\n            });\n            formattedAgentCapabilitiesString += \"---\\n\";\n        });\n\n        const orchestratorSpecialActionsDescription = `\nOrchestrator Special Actions:\n - ExploreSearchResults: This is a special action for the Orchestrator. It should be used AFTER a WebSearchTool step to gather more detailed information from the search results.\n   Input ('sub_task_input'):\n     - 'pagesToExplore': (Optional, Integer, Default: 2) Number of top search result links to read using ReadWebpageTool.\n     - 'relevanceCriteria': (Optional, String) Brief guidance on what makes a search result relevant for deeper exploration (e.g., \"pages offering detailed explanations\", \"official documentation\"). Orchestrator will primarily use the order of results.\n   Functionality: The Orchestrator will take the results from the most recent WebSearchTool step in a preceding stage. It will select up to 'pagesToExplore' links. For each selected link, it will internally use 'ReadWebpageTool' to fetch its content. The collected content from all explored pages will then be aggregated.\n   Output: An aggregated string containing the content from all explored pages.\n   When to use: Use this if the user's task implies needing more than just search snippets and requires information from the content of the web pages found.\n - LLMStepExecutor: This is a special action for the Orchestrator to directly use the configured AI Service (e.g., Gemini, OpenAI) for a specific step that doesn't fit other tools, like complex reasoning, summarization of diverse inputs, or reformatting text.\n   Input ('sub_task_input'):\n     - 'prompt_template': (String) A template for the prompt. Use {{placeholder_name}} for dynamic values. Special param '{previous_step_output}' will be replaced by the output of the immediately preceding step if available.\n     - 'prompt_params': (Optional, Object) Key-value pairs to fill in the prompt_template.\n     - 'prompt': (String, Alternative to template/params) A direct prompt string if no templating is needed.\n     - 'messages': (Array, Alternative to prompt/template) An array of chat messages (e.g., [{role: 'user', content: '...'}, {role: 'assistant', content: '...'}]).\n     - 'model': (Optional, String) Specify a model name if you want this step to use a particular model (e.g., 'gpt-4', 'gemini-pro'). If omitted, a default model configured for the AI service will be used.\n     - 'temperature': (Optional, Number) Sampling temperature.\n     - 'maxTokens': (Optional, Number) Maximum number of tokens to generate.\n     - 'isFinalAnswer': (Optional, Boolean, Default: false) If this step, when assigned to \"Orchestrator\", is intended to produce the final answer to the user's query, set this to true. Example: { \"prompt\": \"Final summary of findings.\", \"isFinalAnswer\": true }.\n   Output: The text generated by the LLM or the content from the assistant's message in chat.\n   When to use: For general LLM-based tasks, summarizations, or when a step requires complex text generation based on context or previous step outputs, especially if it's meant to be the final user-facing response. Также используй \\`LLMStepExecutor\\` для шагов, где требуется анализ ситуации, оценка результатов предыдущих шагов, или принятие решения о дальнейшей стратегии, если это не покрывается другими инструментами.\n - FileSystemTool: Allows Orchestrator to perform file system operations within a sandboxed task-specific workspace.\n   Input ('sub_task_input'):\n     - 'operation': (String) One of [\"create_file\", \"read_file\", \"append_to_file\", \"list_files\", \"overwrite_file\", \"create_pdf_from_text\"].\n     - 'params': (Object) Parameters for the operation:\n       - create_file: { \"filename\": \"string\", \"content\": \"string\", \"directory\"?: \"string\" (optional subdirectory) }\n       - read_file: { \"filename\": \"string\", \"directory\"?: \"string\" }\n       - append_to_file: { \"filename\": \"string\", \"content\": \"string\", \"directory\"?: \"string\" } (content must be non-empty)\n       - list_files: { \"directory\"?: \"string\" (optional subdirectory relative to workspace root), \"recursive\"?: boolean (optional, default: false, if true lists recursively), \"maxDepth\"?: number (optional, default: 3 if recursive, limits recursion depth) }\n       - overwrite_file: (alias for create_file) { \"filename\": \"string\", \"content\": \"string\", \"directory\"?: \"string\" }\n       - create_pdf_from_text: { \"filename\": \"string_ending_with.pdf\", \"text_content\": \"string\", \"directory\"?: \"string\", \"fontSize\"?: number, \"fontName\"?: \"string\", \"customFontFileName\"?: \"string_ending_with.ttf_or_otf\" (e.g., \"DejaVuSans.ttf\", from 'assets/fonts/') }\n   Output: Varies by operation (e.g., success message, file content, or for list_files: Array<{path: string, type: 'file'|'directory'}> where paths are relative to task workspace root).\n   When to use: For tasks requiring intermediate data storage, reading specific files, or organizing outputs within a dedicated workspace for the current task. All paths are relative to the task's workspace root.\n - FileDownloaderTool: Allows Orchestrator to download files from a URL into the task-specific workspace.\n   Input ('sub_task_input'):\n     - 'operation': (String) Must be \"download_file\".\n     - 'params': (Object) { \"url\": \"string_url_to_download\", \"directory\"?: \"string\" (optional subdirectory), \"filename\"?: \"string\" (optional, will try to infer if not provided) }.\n   Output: Success message with path to downloaded file or error.\n   When to use: When a task requires fetching a file from an external URL for later processing or reference. Downloads are subject to size limits.\n---\n(End of available agents list and special actions)`;\n\n        const planFormatInstructions = `\nBased on the user task and available capabilities, create a multi-stage execution plan.\nThe plan MUST be a JSON array of stages. Each stage MUST be a JSON array of sub-task objects.\nSub-tasks within the same stage can be executed in parallel. Stages are executed sequentially.\nEach sub_task object in an inner array must have the following keys:\n1. 'stepId': String (A unique, non-empty identifier for this step within the plan, e.g., \"search_articles\", \"analyze_data_1\"). This ID is used for referencing outputs.\n2. 'assigned_agent_role': String (must be one of [${knownAgentRoles.map(r => `\"${r}\"`).join(\", \")}] OR \"Orchestrator\" for special actions).\n3. 'tool_name': String (must be a tool available to the assigned agent OR a special action name like \"ExploreSearchResults\", \"LLMStepExecutor\", \"FileSystemTool\", \"FileDownloaderTool\").\n4. 'sub_task_input': Object (the input for the specified tool or action).\n   - This input can reference outputs from PREVIOUSLY EXECUTED steps using the syntax \\`@{outputs.SOURCE_STEP_ID.FIELD_NAME}\\`.\n   - \\`SOURCE_STEP_ID\\` must be the 'stepId' of a step that is guaranteed to have completed (e.g., from a previous stage, or an earlier step in the same stage if execution within a stage is sequential for Orchestrator steps).\n   - \\`FIELD_NAME\\` can be 'result_data' (for the raw output of the source step) or 'processed_result_data' (for the summarized/processed output, if available; defaults to raw if not processed).\n   - Example: \\`{ \"content\": \"Summary from previous step: @{outputs.summarize_step.processed_result_data}\" }\\`\n   - For \"LLMStepExecutor\" by \"Orchestrator\", if it's the final answer, include 'isFinalAnswer: true'. It can also take an optional 'model' parameter.\n   - For \"FileSystemTool\" or \"FileDownloaderTool\", this must include 'operation' and 'params'.\n5. 'narrative_step': String (a short, human-readable description of this step's purpose).\n\nFor the 'ExploreSearchResults' action, set 'assigned_agent_role' to \"Orchestrator\" and 'tool_name' to \"ExploreSearchResults\". The 'sub_task_input' may include 'pagesToExplore' and 'relevanceCriteria'.\nFor the 'LLMStepExecutor' action by 'Orchestrator', if it's producing the final user answer, include 'isFinalAnswer: true' in 'sub_task_input'.\nFor 'FileSystemTool' and 'FileDownloaderTool' actions by 'Orchestrator', ensure 'sub_task_input' contains 'operation' and the correct 'params' for that operation.\n\nExample of a plan using FileSystemTool, stepId, and output referencing:\n\\`\\`\\`json\n[\n  [\n    {\n      \"stepId\": \"extract_info\",\n      \"assigned_agent_role\": \"Orchestrator\",\n      \"tool_name\": \"LLMStepExecutor\",\n      \"sub_task_input\": {\n        \"prompt\": \"Extract key information from the user query.\"\n      },\n      \"narrative_step\": \"Extract key information for report generation.\"\n    }\n  ],\n  [\n    {\n      \"stepId\": \"create_report_pdf\",\n      \"assigned_agent_role\": \"Orchestrator\",\n      \"tool_name\": \"FileSystemTool\",\n      \"sub_task_input\": {\n        \"operation\": \"create_pdf_from_text\",\n        \"params\": {\n          \"filename\": \"report_with_extracted_info.pdf\",\n          \"text_content\": \"Report based on: @{outputs.extract_info.result_data}\",\n          \"directory\": \"reports\",\n          \"customFontFileName\": \"DejaVuSans.ttf\"\n        }\n      },\n      \"narrative_step\": \"Create a PDF report using extracted information.\"\n    }\n  ],\n  [\n    {\n      \"stepId\": \"final_confirmation\",\n      \"assigned_agent_role\": \"Orchestrator\",\n      \"tool_name\": \"LLMStepExecutor\",\n      \"sub_task_input\": {\n        \"prompt\": \"The PDF report 'reports/report_with_extracted_info.pdf' has been created. This is the final confirmation.\",\n        \"isFinalAnswer\": true\n      },\n      \"narrative_step\": \"Confirm PDF creation and provide final status.\"\n    }\n  ]\n]\n\\`\\`\\`\n\nIMPORTANT CONSIDERATIONS FOR CONTEXT LENGTH:\n- When using tools that can return large amounts of text, such as Context7DocumentationTool, be mindful of the overall context window of subsequent LLM calls that might use this text.\n- For 'Context7DocumentationTool', if you anticipate the fetched documentation will be used directly in another LLM prompt (e.g., with LLMStepExecutor), consider specifying a 'maxTokens' value in its 'sub_task_input' (e.g., 2000 or 3000) to request a more concise version of the documentation from Context7. This helps prevent exceeding token limits in subsequent steps.\n\nProduce ONLY the JSON array of stages. Do not include any other text before or after the JSON.`;\n\n        let planningPrompt;\n        let sourcePrefix = isRevision ? \"llm_revision\" : \"llm\";\n\n        const PRINCIPLES_OF_GOOD_PLANNING = `\n---\nПринципы Качественного Планирования:\nПрежде чем генерировать JSON-план, продумай следующие аспекты:\n\n1.  **Понимание Цели**: Убедись, что ты точно понял конечную цель задачи пользователя. Если задача неясна, твой первый шаг в плане может быть направлен на уточнение задачи с помощью \\`LLMStepExecutor\\`, запросив у пользователя дополнительные детали.\n2.  **Декомпозиция**: Разбей сложную задачу на более мелкие, управляемые этапы и шаги. Каждый шаг должен иметь четкую, единственную цель.\n3.  **Логическая Последовательность и Зависимости**:\n    *   Располагай шаги в строгой логической последовательности.\n    *   Если шаг Б зависит от результата шага А, убедись, что шаг А выполняется раньше. Используй механизм ссылок \\`@{outputs.STEP_A_ID.result_data}\\` для передачи данных между шагами.\n    *   Кратко описывай зависимости в \\`narrative_step\\`, если это помогает пониманию.\n4.  **Эффективность и Оптимальность**:\n    *   Старайся достичь цели с минимально необходимым количеством шагов. Избегай избыточных или повторяющихся действий.\n    *   Выбирай наиболее подходящий инструмент для каждого шага.\n5.  **Предвидение и Обработка Ошибок (Базовый уровень)**:\n    *   Если какой-то шаг потенциально может завершиться неудачей (например, поиск информации может не дать результатов, или внешний ресурс может быть недоступен), подумай, можно ли добавить альтернативный шаг или шаг для проверки результата.\n    *   Для задач, где результат не гарантирован, план может включать шаги по информированию пользователя о невозможности выполнения или о частичных результатах.\n        *   **Полнота**: Убедись, что план покрывает все аспекты запроса пользователя, если это возможно в рамках одного плана.\n        *   **Конкретность \\`sub_task_input\\`**: Для каждого шага \\`sub_task_input\\` должен быть максимально конкретным и содержать все необходимые параметры для инструмента. Не полагайся на то, что агент \"догадается\".\n\nПомни, что хороший план — это не просто набор шагов, а логически выстроенная стратегия для решения задачи.\n---\n`;\n\n        if (isRevision) {\n            let revisionContext = `This is a replanning attempt (Attempt #${revisionAttemptNumber}) due to a failure in a previous execution.\\n`;\n            revisionContext += `Original User Task: '${userTaskString}'\\n\\n`;\n\n            if (currentCWC) { // currentCWC no longer has keyFindings or errorsEncountered directly\n                revisionContext += \"Current Working Context (CWC) Summary:\\n\";\n                revisionContext += `Overall Progress: ${currentCWC.summaryOfProgress || 'Not available.'}\\n`;\n                revisionContext += \"---\\n\";\n            }\n\n            if (latestKeyFindings && latestKeyFindings.length > 0) {\n                revisionContext += `Recent Key Findings (up to ${latestKeyFindings.length}):\n${JSON.stringify(latestKeyFindings, null, 2)}\n---\n`;\n            }\n            if (latestErrors && latestErrors.length > 0) {\n                revisionContext += `Recent Errors Encountered (up to ${latestErrors.length}):\n${JSON.stringify(latestErrors, null, 2)}\n---\n`;\n            }\n\n            if (failedStepInfo) {\n                revisionContext += \"Information about the failed step:\\n\";\n                revisionContext += `Narrative: ${failedStepInfo.narrative_step || 'N/A'}\\n`;\n                revisionContext += `Agent Role: ${failedStepInfo.assigned_agent_role || 'N/A'}\\n`;\n                revisionContext += `Tool: ${failedStepInfo.tool_name || 'N/A'}\\n`;\n                revisionContext += `Input: ${JSON.stringify(failedStepInfo.sub_task_input, null, 2)}\\n`;\n                revisionContext += `Error Message: ${failedStepInfo.errorMessage || 'N/A'}\\n`;\n                revisionContext += \"---\\n\";\n            }\n\n            if (remainingPlanStages && remainingPlanStages.length > 0) {\n                try {\n                    const remainingPlanString = JSON.stringify(remainingPlanStages, null, 2);\n                    if (remainingPlanString.length < 2000) {\n                        revisionContext += `Remaining plan stages from previous attempt:\\n${remainingPlanString}\\n---\\n`;\n                    }\n                } catch (e) { console.warn(\"PlanManager: Could not stringify remainingPlanStages for revision prompt.\"); }\n            }\n\n            if (executionContextSoFar && executionContextSoFar.length > 0) {\n                try {\n                    const recentContextString = JSON.stringify(executionContextSoFar.slice(-3), null, 2);\n                    revisionContext += `Recent execution context (last 3-5 steps/results):\\n${recentContextString}\\n---\\n`;\n                } catch (e) { console.warn(\"PlanManager: Could not stringify executionContextSoFar for revision prompt.\"); }\n            }\n\n            revisionContext += `Instruction: Given all the information above (original task, capabilities, previous attempt's failure, context, and remaining plan if any), generate a revised plan to achieve the user's objective. You can modify the remaining plan, create a completely new plan, or decide if the task is unachievable. If the task seems unachievable or you cannot devise a recovery plan, return an empty JSON array [] or a plan with a single step explaining why it's not possible using LLMStepExecutor with isFinalAnswer: true.\nТвой новый план должен:\nа) Учитывать причину предыдущего сбоя (из 'Information about the failed step').\nб) Предложить конкретные изменения или альтернативные шаги для обхода проблемы.\nв) Если проблема не в конкретном шаге, а в общей стратегии, пересмотреть стратегию.\nг) Если предыдущие шаги (из 'Recent execution context') дали полезные результаты, старайся их использовать в новом плане, чтобы не делать лишнюю работу.\nд) Если задача действительно невыполнима даже после нескольких попыток, четко объясни это в финальном шаге через \\`LLMStepExecutor\\` с \\`isFinalAnswer: true\\`. Не зацикливайся на создании неработающих планов.`;\n\n            // New approach for revision:\n            let fullRevisionPromptBase;\n            // If megaContext is available, use it as the primary source of information for replanning.\n            // It contains a comprehensive snapshot of the task state (task def, uploaded files, findings, etc.).\n            // The existing revisionContext (failed step details, recent CWC, etc.) is appended to it.\n            if (memoryContext && memoryContext.megaContext && typeof memoryContext.megaContext === 'string' && memoryContext.megaContext.trim() !== '') {\n                fullRevisionPromptBase = `${memoryContext.megaContext}\n\n${revisionContext}`; // Append specific revision details to the general megaContext.\n                sourcePrefix += \"_with_megacontext\"; // Indicate megaContext was used for logging/tracking.\n            } else {\n                // Fallback: If megaContext is not available, use the older method of combining\n                // revisionContext with memoryContextPromptSection (summarized decisions, CWC snapshot).\n                fullRevisionPromptBase = `${revisionContext}${memoryContextPromptSection}`;\n            }\n            planningPrompt = `${fullRevisionPromptBase}\n${PRINCIPLES_OF_GOOD_PLANNING}\n\nAvailable agent capabilities:\n---\n${formattedAgentCapabilitiesString}\n---\n${orchestratorSpecialActionsDescription}\n---\n${planFormatInstructions}`;\n\n        } else {\n            // Logic for initial planning\n            // Check if a pre-assembled megaContext is provided in memoryContext.\n            if (memoryContext && memoryContext.megaContext && typeof memoryContext.megaContext === 'string' && memoryContext.megaContext.trim() !== '') {\n                // If megaContext exists, it becomes the primary informational base for the planning prompt.\n                // It should already contain task definition, uploaded files, key findings, etc.\n                // We then append the userTaskString explicitly for emphasis, followed by standard planning instructions.\n                planningPrompt = `${memoryContext.megaContext}\n\nUser Task (ensure this is addressed by the plan): '${userTaskString}'\n${PRINCIPLES_OF_GOOD_PLANNING}\n\nAvailable agent capabilities:\n---\n${formattedAgentCapabilitiesString}\n---\n${orchestratorSpecialActionsDescription}\n---\n${planFormatInstructions}`;\n                sourcePrefix += \"_with_megacontext\"; // Update source prefix for tracking.\n            } else {\n                // Fallback to the original logic if megaContext is not available.\n                // This constructs the prompt from individual pieces like initialPromptSection (user task)\n                // and memoryContextPromptSection (summarized decisions, CWC snapshot).\n                planningPrompt = `${initialPromptSection}${memoryContextPromptSection}\n${PRINCIPLES_OF_GOOD_PLANNING}\n\nAvailable agent capabilities:\n---\n${formattedAgentCapabilitiesString}\n---\n${orchestratorSpecialActionsDescription}\n---\n${planFormatInstructions}`;\n            }\n        }\n\n        let planJsonString;\n        let llmCallPrompt = planningPrompt; // Start with the fully constructed prompt\n\n        // Determine the model for the LLM call, defaulting appropriately for Gemini or other services.\n        let defaultModelForService = 'gpt-4'; // General default\n        if (this.aiService.getServiceName && this.aiService.getServiceName() === 'GeminiService') {\n            defaultModelForService = 'gemini-1.5-pro-latest'; // Gemini specific default\n        }\n        const llmCallParams = {\n            model: (this.aiService.baseConfig && this.aiService.baseConfig.planningModel) || defaultModelForService\n        };\n\n        // Check if running with GeminiService and if OrchestratorAgent has prepared a CachedContent.\n        if (this.aiService.getServiceName && this.aiService.getServiceName() === 'GeminiService' &&\n            memoryContext && memoryContext.isMegaContextCachedByGemini === true &&\n            memoryContext.geminiCachedContentName) {\n\n            console.log(`PlanManager: Gemini CachedContent (Name: ${memoryContext.geminiCachedContentName}) found. Using short prompt for planning.`);\n\n            if (isRevision) {\n                // For revisions, the prompt needs to instruct the LLM to use the cached context\n                // while also considering the revision-specific details (failure, CWC, etc.).\n                // The 'revisionContext' variable already contains much of this, excluding the full megaContext.\n                // We assume 'userTaskString' is the most direct representation of the overall goal.\n                llmCallPrompt = `Original User Task: '${userTaskString}'.\nThis is a replanning attempt (Attempt #${revisionAttemptNumber}).\nDetailed context including previous attempt's failure, execution history, CWC, key findings, and errors has been provided in the cached content.\nInstruction: Based on ALL available information (original task, cached context, and the specific details of the previous failure), generate a revised plan.\n${PRINCIPLES_OF_GOOD_PLANNING}\nAvailable agent capabilities:\n---\n${formattedAgentCapabilitiesString}\n---\n${orchestratorSpecialActionsDescription}\n---\n${planFormatInstructions}`;\n            } else {\n                // For initial planning with cached content.\n                llmCallPrompt = `User Task: '${userTaskString}'.\nThe necessary context (task definition, uploaded files, key findings, chat history) has been provided and is cached.\n${PRINCIPLES_OF_GOOD_PLANNING}\nAvailable agent capabilities:\n---\n${formattedAgentCapabilitiesString}\n---\n${orchestratorSpecialActionsDescription}\n---\n${planFormatInstructions}\nBased on the cached context and the user task, generate a plan.`;\n            }\n\n            llmCallParams.cachedContentName = memoryContext.geminiCachedContentName;\n            // sourcePrefix might already include \"_with_megacontext\" from earlier logic if megaContext string was present.\n            // This is acceptable as it indicates rich context was available, now via cache.\n        }\n        // If not using Gemini cache, llmCallPrompt remains the original long planningPrompt,\n        // and llmCallParams does not include cachedContentName.\n\n        try {\n            planJsonString = await this.aiService.generateText(llmCallPrompt, llmCallParams);\n        } catch (llmError) {\n            console.error(`PlanManager: Error from AI service during ${sourcePrefix} planning:`, llmError.message);\n            return { success: false, message: `Failed to generate plan due to AI service error: ${llmError.message}`, source: `${sourcePrefix}_service_error`, rawResponse: null };\n        }\n\n        const validationResult = await this.parseAndValidatePlan(planJsonString, knownAgentRoles, knownToolsByRole);\n        if (!validationResult.success) {\n            return { success: false, message: validationResult.message, source: `${sourcePrefix}_validation_error`, rawResponse: validationResult.rawResponse };\n        }\n\n        return { success: true, plan: validationResult.stages, source: sourcePrefix, rawResponse: validationResult.rawResponse };\n    }\n}\n\nmodule.exports = PlanManager;\n","usedDeprecatedRules":[{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]}]