[{"filePath":"/app/agents/OrchestratorAgent.js","messages":[],"suppressedMessages":[{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found writeFile from package \"fs-extra\" with non literal argument at index 0","line":158,"column":31,"nodeType":"CallExpression","endLine":158,"endColumn":75,"suppressions":[{"kind":"directive","justification":"safeFileName is sanitized, path.basename is used, and uploadedFilesDir is a system-controlled path within the task's workspace."}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/app/agents/ResearchAgent.js","messages":[],"suppressedMessages":[{"ruleId":"security/detect-object-injection","severity":1,"message":"Variable Assigned to Object Injection Sink","line":41,"column":30,"nodeType":"MemberExpression","endLine":41,"endColumn":54,"suppressions":[{"kind":"directive","justification":"tool_name is validated by Object.prototype.hasOwnProperty.call against toolsMap prior to this access."}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/app/agents/UtilityAgent.js","messages":[],"suppressedMessages":[{"ruleId":"security/detect-object-injection","severity":1,"message":"Variable Assigned to Object Injection Sink","line":31,"column":30,"nodeType":"MemberExpression","endLine":31,"endColumn":54,"suppressions":[{"kind":"directive","justification":"tool_name is validated by Object.prototype.hasOwnProperty.call against toolsMap prior to this access."}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/app/core/MemoryManager.js","messages":[],"suppressedMessages":[{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":27,"column":17,"nodeType":"MemberExpression","endLine":27,"endColumn":32,"suppressions":[{"kind":"directive","justification":"'key' is from Object.keys(obj) and validated with hasOwnProperty. orderedObj is a fresh local object."}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":27,"column":35,"nodeType":"MemberExpression","endLine":27,"endColumn":43,"suppressions":[{"kind":"directive","justification":"'key' is from Object.keys(obj) and validated with hasOwnProperty. orderedObj is a fresh local object."}]},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found readFile from package \"fs\" with non literal argument at index 0","line":37,"column":35,"nodeType":"CallExpression","endLine":37,"endColumn":65,"suppressions":[{"kind":"directive","justification":"filePath in this internal method is expected to be pre-validated if from untrusted source. Currently unused."}]},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found mkdir from package \"fs\" with non literal argument at index 0","line":91,"column":15,"nodeType":"CallExpression","endLine":91,"endColumn":61,"suppressions":[{"kind":"directive","justification":"memoryBankPath is derived from system-controlled taskDirPath."}]},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found readFile from package \"fs\" with non literal argument at index 0","line":109,"column":35,"nodeType":"CallExpression","endLine":109,"endColumn":65,"suppressions":[{"kind":"directive","justification":"filePath is pre-sanitized by this.getMemoryFilePath()."}]},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found mkdir from package \"fs\" with non literal argument at index 0","line":122,"column":15,"nodeType":"CallExpression","endLine":122,"endColumn":61,"suppressions":[{"kind":"directive","justification":"memoryBankPath is derived from system-controlled taskDirPath."}]},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found writeFile from package \"fs\" with non literal argument at index 0","line":126,"column":15,"nodeType":"CallExpression","endLine":126,"endColumn":62,"suppressions":[{"kind":"directive","justification":"filePath is pre-sanitized by this.getMemoryFilePath()."}]},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found readFile from package \"fs\" with non literal argument at index 0","line":199,"column":39,"nodeType":"CallExpression","endLine":199,"endColumn":77,"suppressions":[{"kind":"directive","justification":"originalFilePath is pre-sanitized by this.getMemoryFilePath()."}]},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found readFile from package \"fs\" with non literal argument at index 0","line":209,"column":54,"nodeType":"CallExpression","endLine":209,"endColumn":95,"suppressions":[{"kind":"directive","justification":"summaryMetaFilePath is derived from a sanitized path."}]},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found readFile from package \"fs\" with non literal argument at index 0","line":212,"column":34,"nodeType":"CallExpression","endLine":212,"endColumn":71,"suppressions":[{"kind":"directive","justification":"summaryFilePath is derived from a sanitized path."}]},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found readFile from package \"fs\" with non literal argument at index 0","line":238,"column":55,"nodeType":"CallExpression","endLine":238,"endColumn":90,"suppressions":[{"kind":"directive","justification":"cacheFilePath is derived from a hash and system paths."}]},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found mkdir from package \"fs\" with non literal argument at index 0","line":273,"column":25,"nodeType":"CallExpression","endLine":273,"endColumn":65,"suppressions":[{"kind":"directive","justification":"cacheDir is derived from system paths."}]},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found writeFile from package \"fs\" with non literal argument at index 0","line":275,"column":19,"nodeType":"CallExpression","endLine":275,"endColumn":185,"suppressions":[{"kind":"directive","justification":"cacheFilePath is derived from a hash and system paths."}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/app/core/MemoryManager.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/app/core/PlanExecutor.js","messages":[{"ruleId":"security/detect-object-injection","severity":1,"message":"Function Call Object Injection Sink","line":58,"column":62,"nodeType":"MemberExpression","endLine":58,"endColumn":87},{"ruleId":"no-unused-vars","severity":1,"message":"'parentTaskId' is defined but never used. Allowed unused args must match /^_/u.","line":106,"column":89,"nodeType":"Identifier","messageId":"unusedVar","endLine":106,"endColumn":101},{"ruleId":"security/detect-object-injection","severity":1,"message":"Variable Assigned to Object Injection Sink","line":360,"column":49,"nodeType":"MemberExpression","endLine":360,"endColumn":62},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":435,"column":137,"nodeType":"MemberExpression","endLine":435,"endColumn":147},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":436,"column":44,"nodeType":"MemberExpression","endLine":436,"endColumn":59},{"ruleId":"security/detect-object-injection","severity":1,"message":"Variable Assigned to Object Injection Sink","line":545,"column":41,"nodeType":"MemberExpression","endLine":545,"endColumn":56},{"ruleId":"security/detect-object-injection","severity":1,"message":"Variable Assigned to Object Injection Sink","line":546,"column":44,"nodeType":"MemberExpression","endLine":546,"endColumn":74}],"suppressedMessages":[{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":46,"column":21,"nodeType":"MemberExpression","endLine":46,"endColumn":46,"suppressions":[{"kind":"directive","justification":"sourceStepId is validated by hasOwnProperty call above. Accessing .status property."}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":48,"column":114,"nodeType":"MemberExpression","endLine":48,"endColumn":139,"suppressions":[{"kind":"directive","justification":"sourceStepId is validated by hasOwnProperty call above. Accessing .status property for error message."}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Variable Assigned to Object Injection Sink","line":53,"column":37,"nodeType":"MemberExpression","endLine":53,"endColumn":79,"suppressions":[{"kind":"directive","justification":"sourceStepId is validated by hasOwnProperty, actualFieldName is from allowed list or checked with hasOwnProperty."}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":53,"column":37,"nodeType":"MemberExpression","endLine":53,"endColumn":62,"suppressions":[{"kind":"directive","justification":"sourceStepId is validated by hasOwnProperty, actualFieldName is from allowed list or checked with hasOwnProperty."}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":62,"column":41,"nodeType":"MemberExpression","endLine":62,"endColumn":83,"suppressions":[{"kind":"directive","justification":"sourceStepId and actualFieldName (now 'result_data') are validated."}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":62,"column":41,"nodeType":"MemberExpression","endLine":62,"endColumn":66,"suppressions":[{"kind":"directive","justification":"sourceStepId and actualFieldName (now 'result_data') are validated."}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Function Call Object Injection Sink","line":74,"column":59,"nodeType":"MemberExpression","endLine":74,"endColumn":84,"suppressions":[{"kind":"directive","justification":"sourceStepId is validated by hasOwnProperty. Using stepOutputs[sourceStepId] as context for hasOwnProperty check on actualFieldName."}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":89,"column":17,"nodeType":"MemberExpression","endLine":89,"endColumn":29,"suppressions":[{"kind":"directive","justification":"'key' is from 'data' (part of sub_task_input from plan). 'newData' is a fresh, local object, limiting impact. Plan generation should ensure 'key' is not malicious (e.g., '__proto__')."}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Function Call Object Injection Sink","line":89,"column":68,"nodeType":"MemberExpression","endLine":89,"endColumn":77,"suppressions":[{"kind":"directive","justification":"'key' is from 'data' (part of sub_task_input from plan). 'newData' is a fresh, local object, limiting impact. Plan generation should ensure 'key' is not malicious (e.g., '__proto__')."}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":164,"column":42,"nodeType":"MemberExpression","endLine":164,"endColumn":61,"suppressions":[{"kind":"directive","justification":"k is a controlled integer index. Accessing known properties."}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":164,"column":87,"nodeType":"MemberExpression","endLine":164,"endColumn":106,"suppressions":[{"kind":"directive","justification":"k is a controlled integer index. Accessing known properties."}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":166,"column":21,"nodeType":"MemberExpression","endLine":166,"endColumn":40,"suppressions":[{"kind":"directive","justification":"k is a controlled integer index. Accessing known properties."}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":166,"column":74,"nodeType":"MemberExpression","endLine":166,"endColumn":93,"suppressions":[{"kind":"directive","justification":"k is a controlled integer index. Accessing known properties."}]},{"ruleId":"security/detect-non-literal-regexp","severity":1,"message":"Found non-literal argument to RegExp Constructor","line":270,"column":41,"nodeType":"NewExpression","endLine":270,"endColumn":87,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Variable Assigned to Object Injection Sink","line":272,"column":41,"nodeType":"MemberExpression","endLine":272,"endColumn":58,"suppressions":[{"kind":"directive","justification":"'key' is from 'promptParams' own properties, checked by hasOwnProperty. Value used for template filling."}]},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found mkdir from package \"fs\" with non literal argument at index 0","line":424,"column":39,"nodeType":"CallExpression","endLine":424,"endColumn":87,"suppressions":[{"kind":"directive","justification":"taskWorkspaceDir is constructed from base path and system-generated parentTaskId."}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Function Call Object Injection Sink","line":441,"column":58,"nodeType":"MemberExpression","endLine":441,"endColumn":73,"suppressions":[{"kind":"directive","justification":"'operation' is validated against an allowed list derived from tool's prototype methods."}]},{"ruleId":"no-undef","severity":2,"message":"'subTaskDefinition' is not defined.","line":556,"column":81,"nodeType":"Identifier","messageId":"undef","endLine":556,"endColumn":98,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-undef","severity":2,"message":"'originalSubTaskDef' is not defined.","line":711,"column":83,"nodeType":"Identifier","messageId":"undef","endLine":711,"endColumn":101,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-undef","severity":2,"message":"'originalSubTaskDef' is not defined.","line":711,"column":165,"nodeType":"Identifier","messageId":"undef","endLine":711,"endColumn":183,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// core/PlanExecutor.js\nconst { v4: uuidv4 } = require('uuid');\nconst path = require('path'); // Added for workspace path construction\nconst fsp = require('fs').promises; // Added for mkdir\nconst { escapeRegExp } = require('../utils/localization'); // Import the escape function\n\nconst ReadWebpageTool = require('../tools/ReadWebpageTool');\nconst FileSystemTool = require('../tools/FileSystemTool'); // Added\nconst FileDownloaderTool = require('../tools/FileDownloaderTool'); // Added\n\nclass PlanExecutor {\n    constructor(subTaskQueue, resultsQueue, aiService, tools = {}, savedTasksBaseDir) { // Changed llmService to aiService\n        this.subTaskQueue = subTaskQueue;\n        this.resultsQueue = resultsQueue;\n        this.aiService = aiService; // Changed llmService to aiService\n        this.tools = tools;\n        this.savedTasksBaseDir = savedTasksBaseDir; // Store this\n        if (!this.savedTasksBaseDir) {\n            // Fallback or error if not provided by Orchestrator, though it should be.\n            console.warn(\"PlanExecutor: savedTasksBaseDir not provided, defaulting to './saved_tasks'. This may be incorrect.\");\n            this.savedTasksBaseDir = path.resolve('./saved_tasks');\n        }\n    }\n\n    async _resolveOutputReferences(data, stepOutputs, currentStepIdForLog = '') {\n        const referenceRegex = /^@{outputs\\.([a-zA-Z0-9_.-]+)\\.(result_data|processed_result_data)}$/; // Full string match\n\n        if (typeof data === 'string') {\n            const match = data.match(referenceRegex);\n            if (match) {\n                const sourceStepId = match[1];\n                const requestedFieldName = match[2];\n\n                // Security: Validate sourceStepId and requestedFieldName\n                // sourceStepId should be an existing key in stepOutputs\n                if (!Object.prototype.hasOwnProperty.call(stepOutputs, sourceStepId)) {\n                    throw new Error(`Unresolved reference: Step ID '${sourceStepId}' not found in outputs (referenced by step ${currentStepIdForLog}).`);\n                }\n                const allowedFieldNames = ['result_data', 'processed_result_data'];\n                if (!allowedFieldNames.includes(requestedFieldName)) {\n                    throw new Error(`Unresolved reference: Invalid field name '${requestedFieldName}' for step '${sourceStepId}' (referenced by step ${currentStepIdForLog}).`);\n                }\n\n                // Strict check for COMPLETED status\n                // eslint-disable-next-line security/detect-object-injection -- sourceStepId is validated by hasOwnProperty call above. Accessing .status property.\n                if (stepOutputs[sourceStepId].status !== \"COMPLETED\") {\n                // eslint-disable-next-line security/detect-object-injection -- sourceStepId is validated by hasOwnProperty call above. Accessing .status property for error message.\n                     throw new Error(`Referenced step '${sourceStepId}' did not complete successfully. Status: ${stepOutputs[sourceStepId].status} (referenced by step ${currentStepIdForLog}). Cannot use its output.`);\n                }\n\n                let actualFieldName = requestedFieldName;\n                // eslint-disable-next-line security/detect-object-injection -- sourceStepId is validated by hasOwnProperty, actualFieldName is from allowed list or checked with hasOwnProperty.\n                let resolvedValue = stepOutputs[sourceStepId][actualFieldName];\n\n                // Fallback logic for processed_result_data\n                if (requestedFieldName === 'processed_result_data' && (resolvedValue === undefined || resolvedValue === null)) {\n                    // Security: Use Object.prototype.hasOwnProperty.call to avoid prototype pollution.\n                    if (Object.prototype.hasOwnProperty.call(stepOutputs[sourceStepId], 'result_data')) { // Check if result_data actually exists\n                        console.warn(`PlanExecutor._resolveOutputReferences: Field 'processed_result_data' for step '${sourceStepId}' is null or undefined. Falling back to 'result_data' (referenced by step ${currentStepIdForLog}).`);\n                        actualFieldName = 'result_data';\n                        // eslint-disable-next-line security/detect-object-injection -- sourceStepId and actualFieldName (now 'result_data') are validated.\n                        resolvedValue = stepOutputs[sourceStepId][actualFieldName];\n                    } else {\n                        // If even result_data doesn't exist (should be rare for completed steps), this is an issue.\n                         console.warn(`PlanExecutor._resolveOutputReferences: Field 'processed_result_data' for step '${sourceStepId}' is null/undefined, and fallback 'result_data' also does not exist (referenced by step ${currentStepIdForLog}).`);\n                        // Keep resolvedValue as is (null/undefined) or throw error based on strictness desired.\n                        // For now, let it pass as null/undefined if both are missing.\n                    }\n                }\n\n                // Check if the (potentially fallback) fieldName actually exists in the output\n                // Security: Use Object.prototype.hasOwnProperty.call to avoid prototype pollution.\n                // eslint-disable-next-line security/detect-object-injection -- sourceStepId is validated by hasOwnProperty. Using stepOutputs[sourceStepId] as context for hasOwnProperty check on actualFieldName.\n                if (!Object.prototype.hasOwnProperty.call(stepOutputs[sourceStepId], actualFieldName)) {\n                     throw new Error(`Unresolved reference: Field '${actualFieldName}' not found in output of step '${sourceStepId}' (referenced by step ${currentStepIdForLog}).`);\n                }\n\n                return resolvedValue;\n            }\n            return data; // Not a reference\n        } else if (Array.isArray(data)) {\n            // Use Promise.all for concurrent async resolution of array items\n            const resolvedArray = await Promise.all(data.map(item => this._resolveOutputReferences(item, stepOutputs, currentStepIdForLog)));\n            return resolvedArray;\n        } else if (typeof data === 'object' && data !== null) {\n            const newData = {};\n            for (const key in data) {\n                // eslint-disable-next-line security/detect-object-injection -- 'key' is from 'data' (part of sub_task_input from plan). 'newData' is a fresh, local object, limiting impact. Plan generation should ensure 'key' is not malicious (e.g., '__proto__').\n                newData[key] = await this._resolveOutputReferences(data[key], stepOutputs, currentStepIdForLog);\n            }\n            return newData;\n        }\n        return data;\n    }\n\n    _createJournalEntry(type, message, details = {}, source = \"PlanExecutor\") {\n        return {\n            timestamp: new Date().toISOString(),\n            type,\n            source,\n            message,\n            details\n        };\n    }\n\n    async _summarizeStepData(dataToSummarize, userTaskString, narrativeStep, subTaskId, parentTaskId) { // Removed journalEntries\n        const MAX_DATA_LENGTH = 1000;\n        let dataString;\n\n        if (typeof dataToSummarize === 'string') {\n            dataString = dataToSummarize;\n        } else {\n            try {\n                dataString = JSON.stringify(dataToSummarize);\n            } catch (e) {\n                console.warn(`PlanExecutor.summarizeDataWithLLM: Could not stringify data for step \"${narrativeStep}\". Using raw data type. Error: ${e.message}`);\n                return dataToSummarize; // Return original data if stringification fails\n            }\n        }\n\n        if (dataString.length > MAX_DATA_LENGTH) {\n            // Journaling for summarization START/SUCCESS/FAILURE will be handled in executePlan\n            console.log(`PlanExecutor._summarizeStepData: Data for step \"${narrativeStep}\" (SubTaskID: ${subTaskId}) is too long (${dataString.length} chars), attempting summarization.`);\n            const summarizationPrompt = `The original user task was: \"${userTaskString}\".\nA step in the execution plan, described as \"${narrativeStep}\", produced the following data:\n---\n${dataString.substring(0, MAX_DATA_LENGTH)}... (data truncated for this prompt if originally longer)\n---\nPlease summarize this data concisely, keeping in mind its relevance to the original user task and the step description. The summary should be a string, suitable for inclusion as context for a final answer synthesis. Focus on extracting key information and outcomes. Provide only the summary text.`;\n            try {\n                // const summary = await this.llmService(summarizationPrompt); // OLD\n                const summary = await this.aiService.generateText(summarizationPrompt, { model: (this.aiService.baseConfig && this.aiService.baseConfig.summarizationModel) || 'gpt-3.5-turbo' }); // NEW\n                if (typeof summary === 'string' && summary.trim() !== \"\") {\n                    console.log(`PlanExecutor._summarizeStepData: Summarization successful for step \"${narrativeStep}\" (SubTaskID: ${subTaskId}).`);\n                    return summary;\n                } else {\n                    console.warn(`PlanExecutor._summarizeStepData: LLM returned empty or non-string summary for step \"${narrativeStep}\" (SubTaskID: ${subTaskId}). Original data (or its beginning) will be used.`);\n                    return dataString.substring(0, MAX_DATA_LENGTH) + (dataString.length > MAX_DATA_LENGTH ? \"... (original data was too long and summarization failed)\" : \"\");\n                }\n            } catch (error) {\n                console.error(`PlanExecutor._summarizeStepData: Error during summarization for step \"${narrativeStep}\" (SubTaskID: ${subTaskId}): ${error.message}`);\n                // Return original (truncated) data in case of error, actual error logging will be in executePlan\n                return dataString.substring(0, MAX_DATA_LENGTH) + (dataString.length > MAX_DATA_LENGTH ? \"... (original data was too long, summarization error occurred)\" : \"\");\n            }\n        }\n        return dataToSummarize;\n    }\n\n    // Signature updated to accept resolvedSubTaskInput\n    async _handleExploreSearchResults(sub_task_id, subTaskDefinition, resolvedSubTaskInput, executionContext, _parentTaskId) { // eslint-disable-line no-unused-vars\n        console.log(`PlanExecutor: Handling special step ExploreSearchResults: \"${subTaskDefinition.narrative_step}\" (SubTaskID: ${sub_task_id}, StepID: ${subTaskDefinition.stepId})`);\n\n        const originalSubTaskInput = subTaskDefinition.sub_task_input;\n        const pageProcessingErrors = []; // Initialize array for partial errors\n\n        let previousSearchResults = null;\n        const searchResultsInput = resolvedSubTaskInput?.searchResults;\n\n        if (searchResultsInput && Array.isArray(searchResultsInput)) {\n            previousSearchResults = searchResultsInput;\n        } else {\n            for (let k = executionContext.length - 1; k >= 0; k--) {\n                // eslint-disable-next-line security/detect-object-injection -- k is a controlled integer index. Accessing known properties.\n                const potentialResults = executionContext[k].processed_result_data || executionContext[k].raw_result_data;\n                // eslint-disable-next-line security/detect-object-injection -- k is a controlled integer index. Accessing known properties.\n                if (executionContext[k].tool_name === \"WebSearchTool\" && executionContext[k].status === \"COMPLETED\" && potentialResults) {\n                    if (Array.isArray(potentialResults)) {\n                        previousSearchResults = potentialResults;\n                    } else if (typeof potentialResults === 'object' && Array.isArray(potentialResults.result)) {\n                        previousSearchResults = potentialResults.result;\n                    }\n                    break;\n                }\n            }\n        }\n\n        if (!previousSearchResults || !Array.isArray(previousSearchResults) || previousSearchResults.length === 0) {\n            console.warn(`PlanExecutor.ExploreSearchResults (StepID: ${subTaskDefinition.stepId}): No valid search results found.`);\n            return {\n                sub_task_id: sub_task_id,\n                stepId: subTaskDefinition.stepId,\n                narrative_step: subTaskDefinition.narrative_step,\n                tool_name: \"ExploreSearchResults\",\n                assigned_agent_role: \"Orchestrator\",\n                sub_task_input: originalSubTaskInput,\n                status: \"COMPLETED\",\n                result_data: \"No search results available to explore or results format was incompatible.\",\n                partial_errors: pageProcessingErrors,\n                error_details: { message: \"No valid search results found to explore.\" }\n            };\n        }\n\n        const pagesToExplore = resolvedSubTaskInput?.pagesToExplore || 2;\n        const linksToRead = previousSearchResults.slice(0, pagesToExplore)\n            .map(item => item && item.link)\n            .filter(link => typeof link === 'string' && link.trim() !== '');\n\n        if (linksToRead.length === 0) {\n            return {\n                sub_task_id: sub_task_id,\n                stepId: subTaskDefinition.stepId,\n                narrative_step: subTaskDefinition.narrative_step,\n                tool_name: \"ExploreSearchResults\",\n                assigned_agent_role: \"Orchestrator\",\n                sub_task_input: originalSubTaskInput,\n                status: \"COMPLETED\",\n                result_data: \"No valid links found in search results to explore.\",\n                partial_errors: pageProcessingErrors,\n                error_details: { message: \"No valid links found in search results to explore.\" }\n            };\n        }\n\n        let aggregatedContent = \"\";\n        const webpageReader = this.tools.ReadWebpageTool || new ReadWebpageTool();\n\n        for (const url of linksToRead) {\n            try {\n                console.log(`PlanExecutor._handleExploreSearchResults: Reading URL - ${url} for SubTaskID: ${sub_task_id}, StepID: ${subTaskDefinition.stepId}`);\n                const readResult = await webpageReader.execute({ url });\n                if (readResult.error) {\n                    const errorDetail = { url: url, errorMessage: readResult.error };\n                    pageProcessingErrors.push(errorDetail);\n                    aggregatedContent += `Error reading ${url}: ${readResult.error}\\n---\\n`;\n                } else if (readResult.result) {\n                    aggregatedContent += `Content from ${url}:\\n${readResult.result}\\n---\\n`;\n                }\n            } catch (e) {\n                const errorDetail = { url: url, errorMessage: e.message };\n                pageProcessingErrors.push(errorDetail);\n                aggregatedContent += `Exception while reading ${url}: ${e.message}\\n---\\n`;\n            }\n        }\n\n        const finalErrorDetails = pageProcessingErrors.length > 0\n            ? { message: `Encountered ${pageProcessingErrors.length} error(s) while processing URLs. See partial_errors for details.` }\n            : null;\n\n        return {\n            sub_task_id: sub_task_id,\n            stepId: subTaskDefinition.stepId,\n            narrative_step: subTaskDefinition.narrative_step,\n            tool_name: \"ExploreSearchResults\",\n            assigned_agent_role: \"Orchestrator\",\n            sub_task_input: originalSubTaskInput,\n            status: \"COMPLETED\", // Step itself completed, even if some pages failed\n            result_data: aggregatedContent.trim() || \"No content could be fetched from the explored pages.\",\n            partial_errors: pageProcessingErrors,\n            error_details: finalErrorDetails\n        };\n    }\n\n    // Signature updated to accept resolvedSubTaskInput, method renamed\n    async _handleLLMStepExecutor(sub_task_id, subTaskDefinition, resolvedSubTaskInput, executionContext, _parentTaskId) { // eslint-disable-line no-unused-vars\n        console.log(`PlanExecutor: Handling special step LLMStepExecutor: \"${subTaskDefinition.narrative_step}\" (SubTaskID: ${sub_task_id}, StepID: ${subTaskDefinition.stepId})`);\n\n        const originalSubTaskInput = subTaskDefinition.sub_task_input;\n        let promptInput = resolvedSubTaskInput?.prompt; // Can be string or array (for chat)\n        const promptTemplate = resolvedSubTaskInput?.prompt_template;\n        const promptParams = resolvedSubTaskInput?.prompt_params || {};\n        const messages = resolvedSubTaskInput?.messages; // For direct chat message input\n\n        if (messages && Array.isArray(messages)) {\n            promptInput = messages; // Use messages array directly if provided\n        } else if (promptTemplate) {\n            promptInput = promptTemplate;\n            for (const key in promptParams) {\n                // Security: Ensure only own properties of promptParams are accessed.\n                if (Object.prototype.hasOwnProperty.call(promptParams, key)) {\n                    const sanitizedKey = escapeRegExp(key); // Sanitize key for RegExp\n                    const placeholder = new RegExp(`{{\\\\s*${sanitizedKey}\\\\s*}}`, 'g'); // eslint-disable-line security/detect-non-literal-regexp\n                    // eslint-disable-next-line security/detect-object-injection -- 'key' is from 'promptParams' own properties, checked by hasOwnProperty. Value used for template filling.\n                    let valueToInject = promptParams[key];\n                    if (valueToInject === \"{previous_step_output}\") {\n                        if (executionContext.length > 0) {\n                        // eslint-disable-next-line security/detect-object-injection -- executionContext is an array, accessing last element with known properties.\n                        const lastStepOutput = executionContext[executionContext.length - 1].processed_result_data || executionContext[executionContext.length - 1].raw_result_data || \"\";\n                        valueToInject = typeof lastStepOutput === 'string' ? lastStepOutput : JSON.stringify(lastStepOutput);\n                    } else {\n                        valueToInject = \"No data from previous steps.\";\n                    }\n                }\n                promptInput = promptInput.replace(placeholder, String(valueToInject));\n              } // Closing for: if (Object.prototype.hasOwnProperty.call(promptParams, key))\n            } // Closing for: for (const key in promptParams)\n\n            // Fallback for {{previous_step_output}} should be applied after all other placeholders are processed\n            if (promptInput.includes(\"{{previous_step_output}}\")) { \n                if (executionContext.length > 0) {\n                    const lastStepOutput = executionContext[executionContext.length - 1].processed_result_data || executionContext[executionContext.length - 1].raw_result_data || \"\";\n                    promptInput = promptInput.replace(new RegExp(\"{{\\\\s*previous_step_output\\\\s*}}\", 'g'), typeof lastStepOutput === 'string' ? lastStepOutput : JSON.stringify(lastStepOutput));\n                } else { // This else is for the inner if (executionContext.length > 0)\n                    promptInput = promptInput.replace(new RegExp(\"{{\\\\s*previous_step_output\\\\s*}}\", 'g'), \"No data from previous steps.\");\n                }\n            }\n        } // Closing for: else if (promptTemplate)\n        // This else if correctly follows the `else if (promptTemplate)`\n        else if (typeof promptInput !== 'string' && !Array.isArray(promptInput)) { \n             promptInput = \"\";\n        }\n\n        // Legacy support for data_from_previous_step if no other prompt/message source\n        if ((!promptInput || (typeof promptInput === 'string' && !promptInput.trim())) && \n            !Array.isArray(promptInput) && \n            resolvedSubTaskInput?.data_from_previous_step === true) {\n            if (executionContext.length > 0) {\n                // eslint-disable-next-line security/detect-object-injection -- executionContext is an array, accessing last element with known properties.\n                const lastStepOutput = executionContext[executionContext.length - 1].processed_result_data || executionContext[executionContext.length - 1].raw_result_data || \"\";\n                promptInput = typeof lastStepOutput === 'string' ? lastStepOutput : JSON.stringify(lastStepOutput);\n            } else {\n                promptInput = \"No data from previous steps to use as prompt.\";\n            }\n        }\n\n        if ((typeof promptInput === 'string' && !promptInput.trim()) || (Array.isArray(promptInput) && promptInput.length === 0)) {\n             return { sub_task_id: sub_task_id, stepId: subTaskDefinition.stepId, narrative_step: subTaskDefinition.narrative_step, tool_name: \"LLMStepExecutor\", assigned_agent_role: \"Orchestrator\", sub_task_input: originalSubTaskInput, status: \"FAILED\", error_details: { message: \"Prompt or messages are empty or invalid for LLMStepExecutor after resolving inputs.\" } };\n        }\n\n        try {\n            let resultData;\n            const stepModel = resolvedSubTaskInput?.model || (this.aiService.baseConfig && this.aiService.baseConfig.defaultLLMStepModel) || 'gpt-3.5-turbo';\n            const stepParams = { model: stepModel };\n            // eslint-disable-next-line security/detect-object-injection -- resolvedSubTaskInput is from plan data, assigning known 'temperature' property to a fresh 'stepParams' object.\n            if (resolvedSubTaskInput?.temperature !== undefined) stepParams.temperature = resolvedSubTaskInput.temperature;\n            // eslint-disable-next-line security/detect-object-injection -- resolvedSubTaskInput is from plan data, assigning known 'maxTokens' property to a fresh 'stepParams' object.\n            if (resolvedSubTaskInput?.maxTokens !== undefined) stepParams.maxTokens = resolvedSubTaskInput.maxTokens;\n\n            if (Array.isArray(promptInput)) {\n                const isValidMessages = promptInput.every(m => typeof m.role === 'string' && typeof m.content === 'string');\n                if (!isValidMessages) throw new Error(\"Invalid message structure for LLMStepExecutor with chat input. Each message must have role and content as strings.\");\n                resultData = await this.aiService.completeChat(promptInput, stepParams);\n            } else if (typeof promptInput === 'string') {\n                resultData = await this.aiService.generateText(promptInput, stepParams);\n            } else {\n                throw new Error(\"Invalid promptInput type for LLMStepExecutor. Must be a string or an array of chat messages.\");\n            }\n            return { sub_task_id: sub_task_id, stepId: subTaskDefinition.stepId, narrative_step: subTaskDefinition.narrative_step, tool_name: \"LLMStepExecutor\", assigned_agent_role: \"Orchestrator\", sub_task_input: originalSubTaskInput, status: \"COMPLETED\", result_data: resultData, error_details: null };\n        } catch (e) {\n            return { sub_task_id: sub_task_id, stepId: subTaskDefinition.stepId, narrative_step: subTaskDefinition.narrative_step, tool_name: \"LLMStepExecutor\", assigned_agent_role: \"Orchestrator\", sub_task_input: originalSubTaskInput, status: \"FAILED\", error_details: { message: e.message } };\n        }\n    }\n\n    async executePlan(planStages, parentTaskId, userTaskString) {\n        const stepOutputs = {}; // Initialize stepOutputs map\n        const journalEntries = [];\n        const executionContext = [];\n        const collectedKeyFindings = [];\n        const collectedErrors = [];\n        let overallSuccess = true;\n        let finalAnswerOutput = null;\n        let finalAnswerWasSynthesized = false;\n        let failedStepDetails = null; // Initialize failedStepDetails\n\n        journalEntries.push(this._createJournalEntry(\n            \"PLAN_EXECUTION_START\",\n            `Starting execution of plan for ParentTaskID: ${parentTaskId}`,\n            { parentTaskId, stageCount: planStages.length }\n        ));\n\n        for (let i = 0; i < planStages.length; i++) {\n            const currentStageTaskDefinitions = planStages[i];\n            const stageIndex = i + 1;\n            journalEntries.push(this._createJournalEntry(\n                \"EXECUTION_STAGE_START\",\n                `Starting Stage ${stageIndex}/${planStages.length}`,\n                { parentTaskId, stageIndex, stageTaskCount: currentStageTaskDefinitions.length }\n            ));\n            console.log(`PlanExecutor: Starting Stage ${stageIndex}/${planStages.length} with ${currentStageTaskDefinitions.length} sub-task(s).`);\n\n            const stageSubTaskPromises = [];\n\n            for (const subTaskDefinition of currentStageTaskDefinitions) {\n                const stepNarrative = subTaskDefinition.narrative_step;\n                const stepId = subTaskDefinition.stepId; // Essential for logging and output tracking\n\n                let resolvedSubTaskInput;\n                try {\n                    // Deep copy original input before resolving, to keep original for contextEntry\n                    const originalInputCopy = JSON.parse(JSON.stringify(subTaskDefinition.sub_task_input));\n                    resolvedSubTaskInput = this._resolveOutputReferences(originalInputCopy, stepOutputs, stepId);\n                } catch (resolutionError) {\n                    console.error(`PlanExecutor: Error resolving output references for stepId '${stepId}': ${resolutionError.message}`);\n                    journalEntries.push(this._createJournalEntry(\n                        \"EXECUTION_STEP_PREPARATION_FAILED\",\n                        `Failed to resolve output references for step: ${stepNarrative} (StepID: ${stepId})`,\n                        { parentTaskId, stageIndex, stepId, narrativeStep: stepNarrative, error: resolutionError.message }\n                    ));\n                    stageSubTaskPromises.push(Promise.resolve({\n                        sub_task_id: uuidv4(), // Generate a sub_task_id for this failure point\n                        stepId: stepId,\n                        narrative_step: stepNarrative,\n                        tool_name: subTaskDefinition.tool_name,\n                        assigned_agent_role: subTaskDefinition.assigned_agent_role,\n                        sub_task_input: subTaskDefinition.sub_task_input, // original input\n                        status: \"FAILED\",\n                        error_details: { message: `Output reference resolution failed: ${resolutionError.message}` }\n                    }));\n                    continue; // Skip to next task in stage\n                }\n\n                // subTaskInputForLog should ideally be the resolved one for better debugging of what the tool *actually* received.\n                // However, the original with @-references is also useful. For now, log original.\n                const subTaskInputForLog = { ...subTaskDefinition.sub_task_input };\n\n\n                if (subTaskDefinition.assigned_agent_role === \"Orchestrator\") {\n                    const sub_task_id_for_orchestrator_step = uuidv4();\n                    journalEntries.push(this._createJournalEntry(\n                        \"EXECUTION_STEP_ORCHESTRATOR_START\",\n                        `Orchestrator starting special step: ${stepNarrative} (StepID: ${stepId})`,\n                        { parentTaskId, stageIndex, subTaskId: sub_task_id_for_orchestrator_step, stepId, narrativeStep: stepNarrative, toolName: subTaskDefinition.tool_name, subTaskInput: subTaskInputForLog }\n                    ));\n                    if (subTaskDefinition.tool_name === \"ExploreSearchResults\") {\n                        // Pass resolvedSubTaskInput and subTaskDefinition\n                        stageSubTaskPromises.push(this._handleExploreSearchResults(sub_task_id_for_orchestrator_step, subTaskDefinition, resolvedSubTaskInput, executionContext, parentTaskId));\n                    } else if (subTaskDefinition.tool_name === \"LLMStepExecutor\") { // Changed from GeminiStepExecutor\n                        // Pass resolvedSubTaskInput and subTaskDefinition\n                        stageSubTaskPromises.push(this._handleLLMStepExecutor(sub_task_id_for_orchestrator_step, subTaskDefinition, resolvedSubTaskInput, executionContext, parentTaskId)); // Renamed method\n                    } else if (subTaskDefinition.tool_name === \"FileSystemTool\" || subTaskDefinition.tool_name === \"FileDownloaderTool\") {\n                        const toolPromise = (async () => {\n                            let tool;\n                            const taskWorkspaceDir = path.join(this.savedTasksBaseDir, parentTaskId, 'workspace');\n                            try {\n                                // eslint-disable-next-line security/detect-non-literal-fs-filename -- taskWorkspaceDir is constructed from base path and system-generated parentTaskId.\n                                await fsp.mkdir(taskWorkspaceDir, { recursive: true });\n                                if (subTaskDefinition.tool_name === \"FileSystemTool\") {\n                                    tool = new FileSystemTool(taskWorkspaceDir);\n                                } else {\n                                    tool = new FileDownloaderTool(taskWorkspaceDir);\n                                }\n                                // Use resolvedSubTaskInput for operations\n                                const operation = resolvedSubTaskInput.operation;\n                                const opParams = resolvedSubTaskInput.params;\n\n                                // Security: Validate the operation name before attempting to call it.\n                                const allowedOperations = Object.getOwnPropertyNames(Object.getPrototypeOf(tool)).filter(prop => typeof tool[prop] === 'function' && !prop.startsWith('_') && prop !== 'constructor');\n                                if (typeof tool[operation] !== 'function' || !allowedOperations.includes(operation) ) {\n                                    throw new Error(`Operation '${operation}' not found or not allowed on tool '${subTaskDefinition.tool_name}'.`);\n                                }\n\n                                // eslint-disable-next-line security/detect-object-injection -- 'operation' is validated against an allowed list derived from tool's prototype methods.\n                                const toolResult = await tool[operation](opParams);\n                                return {\n                                    sub_task_id: sub_task_id_for_orchestrator_step,\n                                    stepId: stepId,\n                                    narrative_step: stepNarrative,\n                                    tool_name: subTaskDefinition.tool_name,\n                                    assigned_agent_role: \"Orchestrator\",\n                                    sub_task_input: subTaskDefinition.sub_task_input, // original input\n                                    status: toolResult.error ? \"FAILED\" : \"COMPLETED\",\n                                    result_data: toolResult.result,\n                                    error_details: toolResult.error ? { message: toolResult.error } : null\n                                };\n                            } catch (err) {\n                                // eslint-disable-next-line security/detect-object-injection -- resolvedSubTaskInput.operation is from plan data, used here for logging purposes only.\n                                console.error(`PlanExecutor: Error executing Orchestrator tool ${subTaskDefinition.tool_name}, operation ${resolvedSubTaskInput.operation} (StepID: ${stepId}): ${err.message}`);\n                                return {\n                                    sub_task_id: sub_task_id_for_orchestrator_step,\n                                    stepId: stepId,\n                                    narrative_step: stepNarrative,\n                                    tool_name: subTaskDefinition.tool_name,\n                                    assigned_agent_role: \"Orchestrator\",\n                                    sub_task_input: subTaskDefinition.sub_task_input, // original input\n                                    status: \"FAILED\",\n                                    error_details: { message: err.message }\n                                };\n                            }\n                        })();\n                        stageSubTaskPromises.push(toolPromise);\n                    } else {\n                         console.error(`PlanExecutor: Unknown tool '${subTaskDefinition.tool_name}' for Orchestrator role. Step: \"${stepNarrative}\" (StepID: ${stepId})`);\n                         stageSubTaskPromises.push(Promise.resolve({\n                            sub_task_id: sub_task_id_for_orchestrator_step,\n                            stepId: stepId,\n                            narrative_step: stepNarrative,\n                            tool_name: subTaskDefinition.tool_name,\n                            assigned_agent_role: \"Orchestrator\",\n                            sub_task_input: subTaskDefinition.sub_task_input, // original input\n                            status: \"FAILED\",\n                            error_details: { message: `Unknown Orchestrator tool: ${subTaskDefinition.tool_name}` }\n                        }));\n                    }\n                } else {\n                    const sub_task_id = uuidv4();\n                    // Use resolvedSubTaskInput for the task message\n                    const taskMessage = { sub_task_id, parent_task_id: parentTaskId, assigned_agent_role: subTaskDefinition.assigned_agent_role, tool_name: subTaskDefinition.tool_name, sub_task_input: resolvedSubTaskInput, narrative_step: stepNarrative, stepId: stepId };\n\n                    journalEntries.push(this._createJournalEntry(\n                        \"EXECUTION_STEP_DISPATCHED\",\n                        `Dispatching step: ${stepNarrative} (SubTaskID: ${sub_task_id}, StepID: ${stepId}) to agent ${taskMessage.assigned_agent_role}`,\n                        { parentTaskId, stageIndex, subTaskId: sub_task_id, stepId, narrativeStep: stepNarrative, toolName: taskMessage.tool_name, agentRole: taskMessage.assigned_agent_role, subTaskInputForLog }\n                    ));\n                    this.subTaskQueue.enqueueTask(taskMessage);\n                    console.log(`PlanExecutor: Dispatched sub-task ${sub_task_id} (StepID: ${stepId}) for role ${taskMessage.assigned_agent_role} - Step: \"${stepNarrative}\" for Stage ${stageIndex}`);\n\n                    const subTaskPromise = new Promise((resolve) => {\n                        this.resultsQueue.subscribeOnce(parentTaskId, (error, resultMsg) => {\n                            const resultDetails = { parentTaskId, stageIndex, subTaskId: sub_task_id, narrativeStep: stepNarrative };\n                            if (error) {\n                                journalEntries.push(this._createJournalEntry(\"EXECUTION_STEP_RESULT_ERROR\", `Error or timeout for SubTaskID: ${sub_task_id}`, { ...resultDetails, error: error.message }));\n                                console.error(`PlanExecutor: Error or timeout waiting for result of sub_task_id ${sub_task_id} (Stage ${stageIndex}):`, error.message);\n                                resolve({ sub_task_id, narrative_step: stepNarrative, tool_name: taskMessage.tool_name, sub_task_input: taskMessage.sub_task_input, assigned_agent_role: taskMessage.assigned_agent_role, status: \"FAILED\", error_details: { message: error.message } });\n                            } else if (resultMsg) {\n                                const resultDataPreview = typeof resultMsg.result_data === 'string' ? resultMsg.result_data.substring(0,100) + '...' : String(resultMsg.result_data);\n                                journalEntries.push(this._createJournalEntry(\"EXECUTION_STEP_RESULT_RECEIVED\", `Result received for SubTaskID: ${sub_task_id}, Status: ${resultMsg.status}`, { ...resultDetails, status: resultMsg.status, agentRole: resultMsg.worker_agent_role, resultDataPreview, errorDetails: resultMsg.error_details }));\n                                if (resultMsg.sub_task_id === sub_task_id) {\n                                    console.log(`PlanExecutor: Received result for sub_task_id ${sub_task_id} (Stage ${stageIndex}). Status: ${resultMsg.status}`);\n                    resolve({\n                        sub_task_id,\n                        stepId: taskMessage.stepId, // Ensure stepId is part of the resolved object\n                        narrative_step: stepNarrative,\n                        tool_name: taskMessage.tool_name,\n                        sub_task_input: subTaskDefinition.sub_task_input, // original input for context\n                        assigned_agent_role: taskMessage.assigned_agent_role,\n                        status: resultMsg.status,\n                        result_data: resultMsg.result_data,\n                        error_details: resultMsg.error_details\n                    });\n                                } else {\n                    const errorMessage = `Critical - Mismatched sub_task_id. Expected ${sub_task_id}, got ${resultMsg.sub_task_id} (StepID: ${taskMessage.stepId})`;\n                    journalEntries.push(this._createJournalEntry(\"EXECUTION_STEP_RESULT_ERROR\", errorMessage, { ...resultDetails, stepId: taskMessage.stepId, expectedSubTaskId: sub_task_id, receivedSubTaskId: resultMsg.sub_task_id }));\n                                    console.error(`PlanExecutor: ${errorMessage} for parent_task_id ${parentTaskId} (Stage ${stageIndex}).`);\n                    resolve({\n                        sub_task_id,\n                        stepId: taskMessage.stepId,\n                        narrative_step: stepNarrative,\n                        tool_name: taskMessage.tool_name,\n                        sub_task_input: subTaskDefinition.sub_task_input,\n                        assigned_agent_role: taskMessage.assigned_agent_role,\n                        status: \"FAILED\",\n                        error_details: { message: \"Mismatched sub_task_id in result processing.\", details: errorMessage }\n                    });\n                                }\n                            }\n                        }, sub_task_id);\n                    });\n                    stageSubTaskPromises.push(subTaskPromise);\n                }\n            }\n\n            const stageResults = await Promise.all(stageSubTaskPromises);\n            const stageContextEntries = [];\n            let firstFailedStepErrorDetails = null;\n\n            for (let j = 0; j < stageResults.length; j++) {\n                const resultOfSubTask = stageResults[j]; // This now includes stepId\n                const originalSubTaskDef = currentStageTaskDefinitions[j]; // This is the definition from the plan\n\n                const subTaskIdForResult = resultOfSubTask.sub_task_id;\n                const stepIdForResult = resultOfSubTask.stepId || originalSubTaskDef.stepId; // Prefer stepId from result if available (e.g. for internally generated failures)\n\n                let processedData = resultOfSubTask.result_data;\n                const summarizationLogDetails = { parentTaskId, stageIndex, subTaskId: subTaskIdForResult, stepId: stepIdForResult, narrativeStep: resultOfSubTask.narrative_step };\n\n                if (resultOfSubTask.status === \"COMPLETED\" && resultOfSubTask.result_data &&\n                    (resultOfSubTask.assigned_agent_role !== \"Orchestrator\" ||\n                     (resultOfSubTask.assigned_agent_role === \"Orchestrator\" && subTaskDefinition.tool_name === \"ExploreSearchResults\"))) { // eslint-disable-line no-undef\n                    journalEntries.push(this._createJournalEntry(\"EXECUTION_DATA_SUMMARIZATION_START\", `Summarizing data for step: ${resultOfSubTask.narrative_step} (StepID: ${stepIdForResult})`, summarizationLogDetails));\n                    const originalDataForPreview = resultOfSubTask.result_data;\n                    try {\n                        const summary = await this._summarizeStepData(resultOfSubTask.result_data, userTaskString, resultOfSubTask.narrative_step, subTaskIdForResult, parentTaskId);\n                        if (summary !== resultOfSubTask.result_data) {\n                             journalEntries.push(this._createJournalEntry(\"EXECUTION_DATA_SUMMARIZATION_SUCCESS\", `Successfully summarized data for step: ${resultOfSubTask.narrative_step} (StepID: ${stepIdForResult})`, { ...summarizationLogDetails, summarizedDataPreview: String(summary).substring(0,100) + \"...\"}));\n                        }\n                        processedData = summary;\n                    } catch (summarizationError) {\n                        journalEntries.push(this._createJournalEntry(\"EXECUTION_DATA_SUMMARIZATION_FAILED\", `Summarization failed for step: ${resultOfSubTask.narrative_step} (StepID: ${stepIdForResult})`, { ...summarizationLogDetails, errorMessage: summarizationError.message }));\n                         console.error(`PlanExecutor: Error during _summarizeStepData call for SubTaskID ${subTaskIdForResult} (StepID: ${stepIdForResult}): ${summarizationError.message}`);\n                        processedData = originalDataForPreview;\n                    }\n                }\n\n                const contextEntry = {\n                    stepId: stepIdForResult, // Ensure stepId is in contextEntry\n                    narrative_step: resultOfSubTask.narrative_step || originalSubTaskDef.narrative_step,\n                    assigned_agent_role: resultOfSubTask.assigned_agent_role || originalSubTaskDef.assigned_agent_role,\n                    tool_name: resultOfSubTask.tool_name || originalSubTaskDef.tool_name,\n                    sub_task_input: originalSubTaskDef.sub_task_input, // Always store the original input with @-references\n                    status: resultOfSubTask.status,\n                    processed_result_data: processedData,\n                    raw_result_data: resultOfSubTask.result_data,\n                    error_details: resultOfSubTask.error_details,\n                    sub_task_id: subTaskIdForResult\n                };\n                stageContextEntries.push(contextEntry);\n\n                // Populate stepOutputs for reference resolution\n                if (contextEntry.stepId) {\n                    // eslint-disable-next-line security/detect-object-injection -- contextEntry.stepId is a UUID or plan-defined ID. Assigning to stepOutputs map.\n                    stepOutputs[contextEntry.stepId] = {\n                        status: contextEntry.status,\n                        result_data: contextEntry.raw_result_data,\n                        processed_result_data: contextEntry.processed_result_data,\n                        error_details: contextEntry.error_details\n                        // Note: partial_errors from ExploreSearchResults are not stored in stepOutputs directly,\n                        // as they are specific to that tool's execution instance.\n                        // They are processed below to be added to collectedErrors for CWC.\n                    };\n                }\n\n                // Process partial_errors from ExploreSearchResults\n                if (contextEntry.tool_name === \"ExploreSearchResults\" &&\n                    resultOfSubTask.partial_errors &&\n                    resultOfSubTask.partial_errors.length > 0) {\n\n                    journalEntries.push(this._createJournalEntry(\n                        \"EXECUTION_STEP_PARTIAL_ERRORS\",\n                        `Step '${contextEntry.narrative_step}' (Tool: ${contextEntry.tool_name}, StepID: ${contextEntry.stepId}) completed with ${resultOfSubTask.partial_errors.length} partial error(s) while processing URLs.`,\n                        {\n                            parentTaskId,\n                            stageIndex: stageIndex,\n                            subTaskId: contextEntry.sub_task_id,\n                            stepId: contextEntry.stepId,\n                            partialErrorCount: resultOfSubTask.partial_errors.length,\n                            errors: resultOfSubTask.partial_errors\n                        }\n                    ));\n\n                    for (const partialErr of resultOfSubTask.partial_errors) {\n                        const encounteredErrorEntry = {\n                            errorId: uuidv4(),\n                            sourceStepNarrative: `${contextEntry.narrative_step} (processing URL: ${partialErr.url || 'Unknown URL'})`,\n                            sourceToolName: contextEntry.tool_name,\n                            // subToolName: \"ReadWebpageTool\", // Optional: if we want this level of detail\n                            errorMessage: partialErr.errorMessage,\n                            timestamp: new Date().toISOString()\n                        };\n                        collectedErrors.push(encounteredErrorEntry);\n                    }\n                }\n\n\n                const logDetails = { parentTaskId, stageIndex, subTaskId: contextEntry.sub_task_id, stepId: contextEntry.stepId, narrativeStep: contextEntry.narrative_step, toolName: contextEntry.tool_name, agentRole: contextEntry.assigned_agent_role };\n                const dataPreviewForLog = contextEntry.processed_result_data !== undefined ? contextEntry.processed_result_data : contextEntry.raw_result_data;\n\n                if (contextEntry.status === \"COMPLETED\") {\n                    journalEntries.push(this._createJournalEntry(\"EXECUTION_STEP_COMPLETED\", `Step completed: ${contextEntry.narrative_step}`, { ...logDetails, processedResultDataPreview: String(dataPreviewForLog).substring(0, 100) + \"...\" }));\n\n                    // Collect Key Finding for CurrentWorkingContext\n                    const findingData = contextEntry.processed_result_data || contextEntry.raw_result_data;\n                    if (findingData || (typeof findingData === 'boolean' || typeof findingData === 'number')) { // Ensure data is not null/undefined, allow boolean/numbers\n                        let dataToStore = findingData;\n                        const MAX_FINDING_DATA_LENGTH = 500;\n                        if (typeof findingData === 'string' && findingData.length > MAX_FINDING_DATA_LENGTH) {\n                            dataToStore = findingData.substring(0, MAX_FINDING_DATA_LENGTH) + \"...\";\n                        } else if (typeof findingData === 'object') {\n                            // Optionally stringify and truncate objects if they can be very large\n                            // For now, keeping small objects as is.\n                            // dataToStore = JSON.stringify(findingData);\n                            // if (dataToStore.length > MAX_FINDING_DATA_LENGTH) dataToStore = dataToStore.substring(0, MAX_FINDING_DATA_LENGTH) + \"...\";\n                        }\n                        const keyFinding = {\n                            findingId: uuidv4(),\n                            sourceStepNarrative: contextEntry.narrative_step,\n                            sourceToolName: contextEntry.tool_name,\n                            data: dataToStore,\n                            timestamp: new Date().toISOString()\n                        };\n                        collectedKeyFindings.push(keyFinding);\n                    }\n\n                } else if (contextEntry.status === \"FAILED\") {\n                    journalEntries.push(this._createJournalEntry(\"EXECUTION_STEP_FAILED\", `Step failed: ${contextEntry.narrative_step}`, { ...logDetails, errorDetails: contextEntry.error_details }));\n                    if (!firstFailedStepErrorDetails) { // This is the first failure in the stage that we're processing\n                        firstFailedStepErrorDetails = contextEntry.error_details || { message: \"Unknown error in failed step.\" };\n                        // Populate failedStepDetails with comprehensive information\n                        failedStepDetails = {\n                            sub_task_id: contextEntry.sub_task_id,\n                            stepId: contextEntry.stepId, // Add stepId here\n                            narrative_step: contextEntry.narrative_step,\n                            tool_name: contextEntry.tool_name,\n                            assigned_agent_role: contextEntry.assigned_agent_role,\n                            sub_task_input: contextEntry.sub_task_input,\n                            error_details: contextEntry.error_details\n                        };\n                        // Ensure sub_task_id is part of firstFailedStepErrorDetails if it was missing before, for compatibility with existing logging\n                        if (!firstFailedStepErrorDetails.sub_task_id && contextEntry.sub_task_id) { // This sub_task_id is the uuid for the execution instance\n                            firstFailedStepErrorDetails.sub_task_id = contextEntry.sub_task_id;\n                        }\n                         // Add stepId to firstFailedStepErrorDetails as well for consistency if needed elsewhere\n                        if (!firstFailedStepErrorDetails.stepId && contextEntry.stepId) {\n                            firstFailedStepErrorDetails.stepId = contextEntry.stepId;\n                        }\n                    }\n                    // Collect Error for CurrentWorkingContext\n                    if (contextEntry.error_details) {\n                        const encounteredError = {\n                            errorId: uuidv4(), // Add an ID for errors as well\n                            sourceStepNarrative: contextEntry.narrative_step,\n                            sourceToolName: contextEntry.tool_name,\n                            errorMessage: contextEntry.error_details.message || JSON.stringify(contextEntry.error_details),\n                            timestamp: new Date().toISOString()\n                        };\n                        collectedErrors.push(encounteredError);\n                    }\n                }\n            }\n            executionContext.push(...stageContextEntries);\n\n            let stageFailed = false;\n            for (const entry of stageContextEntries) {\n                if (entry.status === \"FAILED\") {\n                    console.error(`PlanExecutor: Sub-task ${entry.sub_task_id} (\"${entry.narrative_step}\") failed in Stage ${stageIndex}. Halting further stages.`);\n                    overallSuccess = false;\n                    stageFailed = true;\n                    break;\n                }\n            }\n\n            if (stageFailed) {\n                const reason = firstFailedStepErrorDetails ?\n                               `Step ${firstFailedStepErrorDetails.sub_task_id || originalSubTaskDef.sub_task_id} (\"${firstFailedStepErrorDetails.narrative_step || originalSubTaskDef.narrative_step}\") failed: ${firstFailedStepErrorDetails.message || 'Unknown error'}` : // eslint-disable-line no-undef\n                               \"A step in the stage failed.\"; // eslint-disable-line no-undef\n                journalEntries.push(this._createJournalEntry(\"EXECUTION_STAGE_FAILED\", `Stage ${stageIndex} failed. Reason: ${reason}. Halting plan execution.`, { parentTaskId, stageIndex, reason: firstFailedStepErrorDetails }));\n                break;\n            } else {\n                journalEntries.push(this._createJournalEntry(\"EXECUTION_STAGE_COMPLETED\", `Stage ${stageIndex} completed successfully.`, { parentTaskId, stageIndex }));\n            }\n            console.log(`PlanExecutor: Stage ${stageIndex} completed successfully.`);\n        }\n\n        journalEntries.push(this._createJournalEntry(\n            overallSuccess ? \"PLAN_EXECUTION_COMPLETED\" : \"PLAN_EXECUTION_FAILED\",\n            `Execution of plan for ParentTaskID: ${parentTaskId} finished. Success: ${overallSuccess}`,\n            { parentTaskId, overallSuccess }\n        ));\n        console.log(`PlanExecutor: Finished processing all stages for parentTaskId: ${parentTaskId}. Overall success: ${overallSuccess}`);\n\n        // Check for pre-synthesized final answer\n        if (overallSuccess && executionContext.length > 0) {\n            // eslint-disable-next-line security/detect-object-injection -- executionContext is an array, accessing last element with known properties.\n            const lastStepContext = executionContext[executionContext.length - 1];\n            // eslint-disable-next-line security/detect-object-injection -- lastStepContext is from executionContext array, accessing known 'status' property.\n            if (lastStepContext.status === \"COMPLETED\" &&\n            // eslint-disable-next-line security/detect-object-injection -- lastStepContext is from executionContext array, accessing known 'assigned_agent_role' property.\n                lastStepContext.assigned_agent_role === \"Orchestrator\" &&\n            // eslint-disable-next-line security/detect-object-injection -- lastStepContext is from executionContext array, accessing known 'tool_name' property.\n                lastStepContext.tool_name === \"LLMStepExecutor\" && // Changed from GeminiStepExecutor\n            // eslint-disable-next-line security/detect-object-injection -- lastStepContext is from executionContext array, accessing known 'sub_task_input' property.\n                lastStepContext.sub_task_input && // original sub_task_input\n            // eslint-disable-next-line security/detect-object-injection -- lastStepContext is from executionContext array, accessing known 'sub_task_input.isFinalAnswer' property.\n                lastStepContext.sub_task_input.isFinalAnswer === true) { // Check on original input\n\n                // eslint-disable-next-line security/detect-object-injection -- lastStepContext is from executionContext array, accessing known properties.\n                finalAnswerOutput = lastStepContext.processed_result_data || lastStepContext.raw_result_data;\n                finalAnswerWasSynthesized = true;\n\n                journalEntries.push(this._createJournalEntry(\n                    \"PLAN_EXECUTOR_FINAL_ANSWER_IDENTIFIED\",\n                    \"Final answer was marked as synthesized by PlanExecutor within a plan step.\",\n                    {\n                        parentTaskId,\n                        stepNarrative: lastStepContext.narrative_step,\n                        subTaskId: lastStepContext.sub_task_id,\n                        stepId: lastStepContext.stepId\n                    }\n                ));\n                console.log(`PlanExecutor: Final answer identified as pre-synthesized by step: \"${lastStepContext.narrative_step}\" (StepID: ${lastStepContext.stepId})`);\n            }\n        }\n\n        return {\n            success: overallSuccess,\n            executionContext,\n            journalEntries,\n            updatesForWorkingContext: {\n                keyFindings: collectedKeyFindings,\n                errorsEncountered: collectedErrors\n            },\n            finalAnswer: finalAnswerOutput,\n            finalAnswerSynthesized: finalAnswerWasSynthesized,\n            failedStepDetails: failedStepDetails // Add the new field here\n        };\n    }\n}\n\nmodule.exports = PlanExecutor;\n","usedDeprecatedRules":[{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/app/core/PlanManager.js","messages":[{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":204,"column":42,"nodeType":"MemberExpression","endLine":204,"endColumn":59},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":204,"column":85,"nodeType":"MemberExpression","endLine":204,"endColumn":102},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":204,"column":119,"nodeType":"MemberExpression","endLine":204,"endColumn":136}],"suppressedMessages":[{"ruleId":"security/detect-object-injection","severity":1,"message":"Function Call Object Injection Sink","line":26,"column":55,"nodeType":"MemberExpression","endLine":26,"endColumn":65,"suppressions":[{"kind":"directive","justification":"'key' is from 'input' (plan data). Function is recursive and performs read-only validation checks."}]},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":48,"column":18,"nodeType":"CallExpression","endLine":48,"endColumn":45,"suppressions":[{"kind":"directive","justification":"templatesDir is a constructor-set base path."}]},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":60,"column":21,"nodeType":"CallExpression","endLine":60,"endColumn":44,"suppressions":[{"kind":"directive","justification":"filePath is constructed from a base path and statically defined filenames."}]},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found readFileSync from package \"fs\" with non literal argument at index 0","line":62,"column":45,"nodeType":"CallExpression","endLine":62,"endColumn":78,"suppressions":[{"kind":"directive","justification":"filePath is constructed from a base path and statically defined filenames."}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Variable Assigned to Object Injection Sink","line":86,"column":44,"nodeType":"MemberExpression","endLine":86,"endColumn":82,"suppressions":[{"kind":"directive","justification":"'placeholder' is a key from 'templateInfo.paramMapping', which is part of statically defined templateDefinitions. Safe."}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":88,"column":39,"nodeType":"MemberExpression","endLine":88,"endColumn":56,"suppressions":[{"kind":"directive","justification":"match is a regex exec array, groupIndex is an integer from static config. Array access by integer is safe."}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":88,"column":59,"nodeType":"MemberExpression","endLine":88,"endColumn":76,"suppressions":[{"kind":"directive","justification":"match is a regex exec array, groupIndex is an integer from static config. Array access by integer is safe."}]},{"ruleId":"security/detect-non-literal-regexp","severity":1,"message":"Found non-literal argument to RegExp Constructor","line":91,"column":83,"nodeType":"NewExpression","endLine":91,"endColumn":129,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// core/PlanManager.js\nconst fs = require('fs');\nconst path = require('path');\nconst { escapeRegExp } = require('../utils/localization'); // Import the escape function\n\n// Helper function moved to module scope\nfunction findInvalidOutputReferences(input, currentStepId, outputRefRegex) {\n    if (typeof input === 'string') {\n        const potentialRefs = input.match(/@{outputs\\.([^}]+)}/g);\n        if (potentialRefs) {\n            for (const ref of potentialRefs) {\n                outputRefRegex.lastIndex = 0; \n                if (!outputRefRegex.test(ref)) {\n                    return `Invalid output reference syntax in: \"${ref}\" for stepId '${currentStepId}'. Must be @{outputs.ID.result_data} or @{outputs.ID.processed_result_data}.`;\n                }\n            }\n        }\n    } else if (Array.isArray(input)) {\n        for (const item of input) {\n            const error = findInvalidOutputReferences(item, currentStepId, outputRefRegex);\n            if (error) return error;\n        }\n    } else if (typeof input === 'object' && input !== null) {\n        for (const key in input) {\n            // eslint-disable-next-line security/detect-object-injection -- 'key' is from 'input' (plan data). Function is recursive and performs read-only validation checks.\n            const error = findInvalidOutputReferences(input[key], currentStepId, outputRefRegex);\n            if (error) return error;\n        }\n    }\n    return null; // No error\n}\n\nclass PlanManager {\n    constructor(aiService, agentCapabilities, planTemplatesPath) { // Changed llmService to aiService\n        this.aiService = aiService; // Changed llmService to aiService\n        this.agentCapabilities = agentCapabilities; // Full capabilities object/array\n        this.planTemplatesPath = planTemplatesPath; // Base path for templates, e.g., path.join(__dirname, '..', 'config', 'plan_templates')\n        this.planTemplates = [];\n        this.loadPlanTemplates();\n    }\n\n    loadPlanTemplates() {\n        // Adapted from OrchestratorAgent.loadPlanTemplates()\n        const templatesDir = this.planTemplatesPath;\n        this.planTemplates = []; // Reset before loading\n        try {\n            // eslint-disable-next-line security/detect-non-literal-fs-filename -- templatesDir is a constructor-set base path.\n            if (!fs.existsSync(templatesDir)) {\n                console.warn(`PlanManager: Plan templates directory not found at ${templatesDir}. No templates loaded.`);\n                return;\n            }\n            // These definitions might need to be passed in or made more generic if they change often\n            const templateDefinitions = [\n                { name: \"weather_query\", fileName: \"weather_query_template.json\", regex: /^(?:what is the )?weather (?:in )?(.+)/i, paramMapping: { CITY_NAME: 1 } },\n                { name: \"calculator\", fileName: \"calculator_template.json\", regex: /^(?:calculate|what is) ([\\d\\s+\\-*/().^%]+)/i, paramMapping: { EXPRESSION: 1 } }\n            ];\n            for (const def of templateDefinitions) {\n                const filePath = path.join(templatesDir, def.fileName);\n                // eslint-disable-next-line security/detect-non-literal-fs-filename -- filePath is constructed from a base path and statically defined filenames.\n                if (fs.existsSync(filePath)) {\n                    // eslint-disable-next-line security/detect-non-literal-fs-filename -- filePath is constructed from a base path and statically defined filenames.\n                    const templateContent = fs.readFileSync(filePath, 'utf8');\n                    this.planTemplates.push({ name: def.name, regex: def.regex, paramMapping: def.paramMapping, template: JSON.parse(templateContent) });\n                    console.log(`PlanManager: Loaded plan template '${def.name}' from ${def.fileName}`);\n                } else {\n                    console.warn(`PlanManager: Plan template file ${def.fileName} not found in ${templatesDir}`);\n                }\n            }\n        } catch (error) {\n            console.error(`PlanManager: Error loading plan templates: ${error.message}`);\n            this.planTemplates = [];\n        }\n    }\n\n    async tryGetPlanFromTemplate(userTaskString) {\n        // Adapted from OrchestratorAgent.tryGetPlanFromTemplate()\n        if (!this.planTemplates || this.planTemplates.length === 0) return null;\n        for (const templateInfo of this.planTemplates) {\n            const match = templateInfo.regex.exec(userTaskString);\n            if (match) {\n                console.log(`PlanManager: Matched plan template '${templateInfo.name}' for task.`);\n                let populatedTemplateString = JSON.stringify(templateInfo.template);\n                for (const placeholder in templateInfo.paramMapping) {\n                    if (Object.prototype.hasOwnProperty.call(templateInfo.paramMapping, placeholder)) {\n                        // eslint-disable-next-line security/detect-object-injection -- 'placeholder' is a key from 'templateInfo.paramMapping', which is part of statically defined templateDefinitions. Safe.\n                        const groupIndex = templateInfo.paramMapping[placeholder];\n                        // eslint-disable-next-line security/detect-object-injection -- match is a regex exec array, groupIndex is an integer from static config. Array access by integer is safe.\n                        const value = match[groupIndex] ? match[groupIndex].trim() : \"\";\n                        // Security: Sanitize placeholder for use in RegExp.\n                        const sanitizedPlaceholder = escapeRegExp(placeholder);\n                        populatedTemplateString = populatedTemplateString.replace(new RegExp(`{{${sanitizedPlaceholder}}}`, 'g'), value); // eslint-disable-line security/detect-non-literal-regexp\n                    }\n                }\n                try {\n                    return JSON.parse(populatedTemplateString);\n                } catch (e) {\n                    console.error(`PlanManager: Error parsing populated template '${templateInfo.name}'. Error: ${e.message}`);\n                    return null;\n                }\n            }\n        }\n        return null;\n    }\n\n    async parseAndValidatePlan(jsonStringResponse, knownAgentRoles, knownToolsByRole) {\n        // Adapted from global parseSubTaskPlanResponse in OrchestratorAgent.js\n        const MAX_RAW_RESPONSE_LENGTH = 500;\n        let cleanedString = jsonStringResponse;\n\n        if (typeof jsonStringResponse !== 'string') {\n            const detailsString = String(jsonStringResponse);\n            const trimmedDetails = detailsString.length > MAX_RAW_RESPONSE_LENGTH ? detailsString.substring(0, MAX_RAW_RESPONSE_LENGTH) + \"...\" : detailsString;\n            return { success: false, message: \"LLM did not return a string response for the plan.\", details: trimmedDetails, stages: [], rawResponse: jsonStringResponse };\n        }\n\n        try {\n            if (cleanedString.startsWith('```json')) {\n                cleanedString = cleanedString.substring(7);\n                if (cleanedString.endsWith('```')) {\n                    cleanedString = cleanedString.slice(0, -3);\n                }\n            }\n            cleanedString = cleanedString.trim();\n            const parsedStages = JSON.parse(cleanedString);\n\n            if (!Array.isArray(parsedStages)) {\n                return { success: false, message: \"LLM plan is not a JSON array of stages.\", rawResponse: cleanedString, stages: [] };\n            }\n            // Allow empty plan for \"unachievable task\" scenario in replanning.\n            // OrchestratorAgent will handle this (e.g., if planStages is empty after this call).\n            if (parsedStages.length === 0 && cleanedString.trim() !== \"[]\") { // check if it's genuinely empty vs bad parse for non-array\n                return { success: false, message: \"LLM plan is empty (no stages), but not an empty array '[]'.\", rawResponse: cleanedString, stages: [] };\n            }\n             if (parsedStages.length === 0 && cleanedString.trim() === \"[]\") {\n                console.log(\"PlanManager: Parsed an empty plan ('[]'). This is treated as a valid plan indicating no actions to take or task unachievable.\");\n                return { success: true, stages: [], rawResponse: cleanedString, isEmptyPlan: true };\n            }\n\n\n            const allStepIds = new Set();\n            let totalSteps = 0;\n            const outputRefRegex = /@{outputs\\.([a-zA-Z0-9_.-]+)\\.(result_data|processed_result_data)}/g; // g for multiple matches in one string\n\n            for (const stage of parsedStages) {\n                if (!Array.isArray(stage)) {\n                    return { success: false, message: \"Invalid stage in plan: not an array.\", rawResponse: cleanedString, stages: [] };\n                }\n                // Allow empty stages within a non-empty plan\n                // if (stage.length === 0) {\n                //     return { success: false, message: \"Invalid stage in plan: stage is empty.\", rawResponse: cleanedString, stages: [] };\n                // }\n                for (const subTask of stage) {\n                    totalSteps++;\n                    if (typeof subTask !== 'object' || subTask === null) {\n                        return { success: false, message: \"Invalid sub-task structure: not an object.\", rawResponse: cleanedString, stages: [] };\n                    }\n\n                    // Validate stepId\n                    if (!subTask.stepId || typeof subTask.stepId !== 'string' || subTask.stepId.trim() === \"\") {\n                        return { success: false, message: `Missing or invalid 'stepId' (must be a non-empty string) in sub-task: ${JSON.stringify(subTask).substring(0,100)}...`, rawResponse: cleanedString, stages: [] };\n                    }\n                    allStepIds.add(subTask.stepId);\n\n                    // Validate narrative_step\n                    if (!subTask.narrative_step || typeof subTask.narrative_step !== 'string' || !subTask.narrative_step.trim()) {\n                        return { success: false, message: `Missing or empty 'narrative_step' for stepId '${subTask.stepId}'.`, rawResponse: cleanedString, stages: [] };\n                    }\n\n                    // Validate assigned_agent_role and tool_name\n                    if (subTask.assigned_agent_role === \"Orchestrator\") {\n                        const allowedOrchestratorTools = [\"ExploreSearchResults\", \"LLMStepExecutor\", \"FileSystemTool\", \"FileDownloaderTool\"]; // Renamed GeminiStepExecutor\n                        if (!allowedOrchestratorTools.includes(subTask.tool_name)) {\n                            return { success: false, message: `Invalid 'tool_name': ${subTask.tool_name} for Orchestrator role (stepId: ${subTask.stepId}). Allowed: ${allowedOrchestratorTools.join(\", \")}.`, rawResponse: cleanedString, stages: [] };\n                        }\n\n                        if (subTask.tool_name === \"LLMStepExecutor\") { // Validation for LLMStepExecutor\n                            if (!subTask.sub_task_input || (typeof subTask.sub_task_input.prompt !== 'string' && typeof subTask.sub_task_input.prompt_template !== 'string' && !Array.isArray(subTask.sub_task_input.messages))) {\n                                return { success: false, message: `'prompt' (string), 'prompt_template' (string), or 'messages' (array) is required in sub_task_input for LLMStepExecutor (stepId: ${subTask.stepId}).`, rawResponse: cleanedString, stages: [] };\n                            }\n                            if (subTask.sub_task_input.model !== undefined && typeof subTask.sub_task_input.model !== 'string') {\n                                return { success: false, message: `'model' in sub_task_input for LLMStepExecutor must be a string if provided (stepId: ${subTask.stepId}).`, rawResponse: cleanedString, stages: [] };\n                            }\n                        } else if (subTask.tool_name === \"FileSystemTool\" || subTask.tool_name === \"FileDownloaderTool\") {\n                            if (!subTask.sub_task_input || typeof subTask.sub_task_input.operation !== 'string') {\n                                return { success: false, message: `'operation' is required in sub_task_input for Orchestrator tool ${subTask.tool_name} (stepId: ${subTask.stepId}).`, rawResponse: cleanedString, stages: [] };\n                            }\n                            if (!subTask.sub_task_input.params || typeof subTask.sub_task_input.params !== 'object') {\n                                return { success: false, message: `'params' object is required in sub_task_input for Orchestrator tool ${subTask.tool_name} (stepId: ${subTask.stepId}).`, rawResponse: cleanedString, stages: [] };\n                            }\n                        }\n\n                        if (subTask.tool_name === \"FileSystemTool\") {\n                            const fsOps = [\"create_file\", \"read_file\", \"append_to_file\", \"list_files\", \"overwrite_file\", \"create_pdf_from_text\"];\n                            if (!fsOps.includes(subTask.sub_task_input.operation)) {\n                                return { success: false, message: `Invalid 'operation': ${subTask.sub_task_input.operation} for FileSystemTool (stepId: ${subTask.stepId}). Allowed: ${fsOps.join(\", \")}`, rawResponse: cleanedString, stages: [] };\n                            }\n                            const opsRequiringStaticFilenameOrDir = {\n                                \"create_file\": [\"filename\"], \"read_file\": [\"filename\"], \"append_to_file\": [\"filename\"],\n                                \"overwrite_file\": [\"filename\"], \"create_pdf_from_text\": [\"filename\"], \"list_files\": [\"directory\"]\n                            };\n                            if (opsRequiringStaticFilenameOrDir[subTask.sub_task_input.operation]) {\n                                const params = subTask.sub_task_input.params;\n                                for (const paramName of opsRequiringStaticFilenameOrDir[subTask.sub_task_input.operation]) {\n                                     if (params[paramName] !== undefined && (typeof params[paramName] !== 'string' || params[paramName].startsWith(\"@{outputs.\"))) {\n                                        return { success: false, message: `'params.${paramName}' must be a string (not an output reference) for FileSystemTool operation '${subTask.sub_task_input.operation}' (stepId: ${subTask.stepId}).`, rawResponse: cleanedString, stages: [] };\n                                    }\n                                }\n                            }\n                             if ((subTask.sub_task_input.operation === \"create_file\" ||\n                                 subTask.sub_task_input.operation === \"read_file\" ||\n                                 subTask.sub_task_input.operation === \"append_to_file\" ||\n                                 subTask.sub_task_input.operation === \"overwrite_file\" ||\n                                 subTask.sub_task_input.operation === \"create_pdf_from_text\") &&\n                                (!subTask.sub_task_input.params || typeof subTask.sub_task_input.params.filename !== 'string')) {\n                                return { success: false, message: `'params.filename' (string) is required for FileSystemTool operation '${subTask.sub_task_input.operation}' (stepId: ${subTask.stepId}).`, rawResponse: cleanedString, stages: [] };\n                            }\n                            if (subTask.sub_task_input.operation === \"create_pdf_from_text\") {\n                                if (!subTask.sub_task_input.params.filename.toLowerCase().endsWith('.pdf')) {\n                                    return { success: false, message: `'params.filename' for 'create_pdf_from_text' must end with '.pdf' (stepId: ${subTask.stepId}).`, rawResponse: cleanedString, stages: [] };\n                                }\n                                if (typeof subTask.sub_task_input.params.text_content !== 'string') {\n                                    return { success: false, message: `'params.text_content' (string or output reference) is required for 'create_pdf_from_text' (stepId: ${subTask.stepId}).`, rawResponse: cleanedString, stages: [] };\n                                }\n                                // ... other PDF params validation ...\n                            }\n                            if ((subTask.sub_task_input.operation === \"create_file\" ||\n                                 subTask.sub_task_input.operation === \"append_to_file\" ||\n                                 subTask.sub_task_input.operation === \"overwrite_file\") &&\n                                (typeof subTask.sub_task_input.params.content !== 'string')\n                               ) {\n                                 if (subTask.sub_task_input.operation !== \"append_to_file\" || subTask.sub_task_input.params.content === undefined) {\n                                     return { success: false, message: `'params.content' (string or output reference) is required for FileSystemTool operation '${subTask.sub_task_input.operation}' (stepId: ${subTask.stepId}).`, rawResponse: cleanedString, stages: [] };\n                                 }\n                            }\n                        }\n                        if (subTask.tool_name === \"FileDownloaderTool\") {\n                            if (subTask.sub_task_input.operation !== \"download_file\") {\n                                return { success: false, message: `Invalid 'operation': ${subTask.sub_task_input.operation} for FileDownloaderTool (stepId: ${subTask.stepId}). Must be 'download_file'.`, rawResponse: cleanedString, stages: [] };\n                            }\n                            if (!subTask.sub_task_input.params || typeof subTask.sub_task_input.params.url !== 'string') {\n                                return { success: false, message: `'params.url' (string or output reference) is required for FileDownloaderTool (stepId: ${subTask.stepId}).`, rawResponse: cleanedString, stages: [] };\n                            }\n                            if (subTask.sub_task_input.params && subTask.sub_task_input.params.filename !== undefined && (typeof subTask.sub_task_input.params.filename !== 'string' || subTask.sub_task_input.params.filename.startsWith(\"@{outputs.\"))) {\n                                return { success: false, message: `'params.filename' if provided, must be a string (not an output reference) for FileDownloaderTool (stepId: ${subTask.stepId}).`, rawResponse: cleanedString, stages: [] };\n                            }\n                        }\n\n                    } else if (!knownAgentRoles.includes(subTask.assigned_agent_role)) {\n                        // eslint-disable-next-line security/detect-object-injection -- subTask.assigned_agent_role is used in a string for an error message, not for property access. Safe.\n                        return { success: false, message: `Invalid or unknown 'assigned_agent_role': ${subTask.assigned_agent_role} for stepId '${subTask.stepId}'.`, rawResponse: cleanedString, stages: [] };\n                    } else { // Worker agent roles\n                        // eslint-disable-next-line security/detect-object-injection -- subTask.assigned_agent_role is validated by knownAgentRoles.includes() check above.\n                        const agentTools = knownToolsByRole[subTask.assigned_agent_role];\n                        if (!subTask.tool_name || typeof subTask.tool_name !== 'string' || !agentTools || !agentTools.includes(subTask.tool_name)) {\n                            // eslint-disable-next-line security/detect-object-injection -- subTask.tool_name and subTask.assigned_agent_role are used in a string for an error message. Safe.\n                            return { success: false, message: `Invalid or unknown 'tool_name': ${subTask.tool_name} for role ${subTask.assigned_agent_role} (stepId: ${subTask.stepId}).`, rawResponse: cleanedString, stages: [] };\n                        }\n                    }\n\n                    if (typeof subTask.sub_task_input !== 'object' || subTask.sub_task_input === null) {\n                        return { success: false, message: `Invalid 'sub_task_input': must be an object for stepId '${subTask.stepId}'.`, rawResponse: cleanedString, stages: [] };\n                    }\n\n                    // Validate output reference syntax within sub_task_input\n                    const refValidationError = findInvalidOutputReferences(subTask.sub_task_input, subTask.stepId, outputRefRegex);\n                    if (refValidationError) {\n                        return { success: false, message: refValidationError, rawResponse: cleanedString, stages: [] };\n                    }\n                }\n            }\n\n            if (totalSteps > 0 && allStepIds.size !== totalSteps) { // Only if there are steps, check for duplicates\n                return { success: false, message: \"Duplicate 'stepId' found in the plan. All stepIds must be unique.\", rawResponse: cleanedString, stages: [] };\n            }\n\n            return { success: true, stages: parsedStages, rawResponse: cleanedString };\n        } catch (e) {\n            const trimmedRawResponse = cleanedString.length > MAX_RAW_RESPONSE_LENGTH ? cleanedString.substring(0, MAX_RAW_RESPONSE_LENGTH) + \"...\" : cleanedString;\n            console.error(\"PlanManager: Error parsing sub-task plan JSON:\", e.message, \"Raw response:\", trimmedRawResponse);\n            return { success: false, message: \"Failed to parse LLM plan: \" + e.message, rawResponse: trimmedRawResponse, stages: [] };\n        }\n    }\n\n    async getPlan(\n        userTaskString,\n        knownAgentRoles,\n        knownToolsByRole,\n        memoryContext = null, // New parameter\n        currentCWC = null,\n        executionContextSoFar = null,\n        failedStepInfo = null,\n        remainingPlanStages = null,\n        isRevision = false,\n        revisionAttemptNumber = 0,\n        latestKeyFindings = [], // New parameter\n        latestErrors = []      // New parameter\n    ) {\n        let initialPromptSection = `User task: '${userTaskString}'.`;\n        if (memoryContext && memoryContext.taskDefinition && memoryContext.taskDefinition !== userTaskString) {\n            initialPromptSection = `Original task definition from memory: \"${memoryContext.taskDefinition}\"\nCurrent user request (if refining or different): \"${userTaskString}\"`;\n        } else if (memoryContext && memoryContext.taskDefinition) {\n            initialPromptSection = `User task (from memory): \"${memoryContext.taskDefinition}\"`;\n        }\n\n        let memoryContextPromptSection = \"\";\n        if (memoryContext) {\n            if (memoryContext.retrievedKeyDecisions && memoryContext.retrievedKeyDecisions.trim() !== \"\") {\n                memoryContextPromptSection += `\n\nPreviously noted key decisions and learnings:\n---\n${memoryContext.retrievedKeyDecisions}\n---`;\n            }\n            if (memoryContext.retrievedCwcSnapshot && Object.keys(memoryContext.retrievedCwcSnapshot).length > 0) {\n                const cwcSnap = memoryContext.retrievedCwcSnapshot;\n                let cwcSummaryForPrompt = `\n\nSnapshot of relevant prior working context (summary):\n- Prior Progress Summary: ${cwcSnap.summaryOfProgress || 'N/A'}\n- Prior Next Objective: ${cwcSnap.nextObjective || 'N/A'}\n- Prior Key Findings (count): ${(cwcSnap.keyFindings && cwcSnap.keyFindings.length) || 0}\n- Prior Errors Encountered (count): ${(cwcSnap.errorsEncountered && cwcSnap.errorsEncountered.length) || 0}`;\n                memoryContextPromptSection += `${cwcSummaryForPrompt}\n---`;\n            }\n        }\n\n        if (!isRevision) {\n            const templatePlan = await this.tryGetPlanFromTemplate(userTaskString);\n            if (templatePlan) {\n                if (Array.isArray(templatePlan) && templatePlan.every(stage => Array.isArray(stage))) {\n                    return { success: true, plan: templatePlan, source: \"template\", rawResponse: null };\n                } else {\n                    console.error(\"PlanManager: Template plan is not in the expected format (array of stages). Falling back to LLM.\");\n                }\n            }\n            console.log(\"PlanManager: No valid matching template found or template was invalid, proceeding with LLM-based planning for initial plan.\");\n        } else {\n            console.log(`PlanManager: Proceeding with LLM-based replanning. Attempt: ${revisionAttemptNumber}`);\n        }\n\n        let formattedAgentCapabilitiesString = \"\";\n        if (!this.agentCapabilities || this.agentCapabilities.length === 0) {\n            console.error(\"PlanManager: No worker agent capabilities defined. Cannot proceed with LLM planning.\");\n            return { success: false, message: \"Internal Server Error: No worker agent capabilities configured for LLM planning.\", source: \"internal_error\", rawResponse: null };\n        }\n        this.agentCapabilities.forEach(agent => {\n            formattedAgentCapabilitiesString += `Agent Role: ${agent.role}\\n`;\n            formattedAgentCapabilitiesString += `Description: ${agent.description}\\n`;\n            formattedAgentCapabilitiesString += `Tools:\\n`;\n            agent.tools.forEach(tool => {\n                formattedAgentCapabilitiesString += `  - ${tool.name}: ${tool.description}\\n`;\n            });\n            formattedAgentCapabilitiesString += \"---\\n\";\n        });\n\n        const orchestratorSpecialActionsDescription = `\nOrchestrator Special Actions:\n - ExploreSearchResults: This is a special action for the Orchestrator. It should be used AFTER a WebSearchTool step to gather more detailed information from the search results.\n   Input ('sub_task_input'):\n     - 'pagesToExplore': (Optional, Integer, Default: 2) Number of top search result links to read using ReadWebpageTool.\n     - 'relevanceCriteria': (Optional, String) Brief guidance on what makes a search result relevant for deeper exploration (e.g., \"pages offering detailed explanations\", \"official documentation\"). Orchestrator will primarily use the order of results.\n   Functionality: The Orchestrator will take the results from the most recent WebSearchTool step in a preceding stage. It will select up to 'pagesToExplore' links. For each selected link, it will internally use 'ReadWebpageTool' to fetch its content. The collected content from all explored pages will then be aggregated.\n   Output: An aggregated string containing the content from all explored pages.\n   When to use: Use this if the user's task implies needing more than just search snippets and requires information from the content of the web pages found.\n - LLMStepExecutor: This is a special action for the Orchestrator to directly use the configured AI Service (e.g., Gemini, OpenAI) for a specific step that doesn't fit other tools, like complex reasoning, summarization of diverse inputs, or reformatting text.\n   Input ('sub_task_input'):\n     - 'prompt_template': (String) A template for the prompt. Use {{placeholder_name}} for dynamic values. Special param '{previous_step_output}' will be replaced by the output of the immediately preceding step if available.\n     - 'prompt_params': (Optional, Object) Key-value pairs to fill in the prompt_template.\n     - 'prompt': (String, Alternative to template/params) A direct prompt string if no templating is needed.\n     - 'messages': (Array, Alternative to prompt/template) An array of chat messages (e.g., [{role: 'user', content: '...'}, {role: 'assistant', content: '...'}]).\n     - 'model': (Optional, String) Specify a model name if you want this step to use a particular model (e.g., 'gpt-4', 'gemini-pro'). If omitted, a default model configured for the AI service will be used.\n     - 'temperature': (Optional, Number) Sampling temperature.\n     - 'maxTokens': (Optional, Number) Maximum number of tokens to generate.\n     - 'isFinalAnswer': (Optional, Boolean, Default: false) If this step, when assigned to \"Orchestrator\", is intended to produce the final answer to the user's query, set this to true. Example: { \"prompt\": \"Final summary of findings.\", \"isFinalAnswer\": true }.\n   Output: The text generated by the LLM or the content from the assistant's message in chat.\n   When to use: For general LLM-based tasks, summarizations, or when a step requires complex text generation based on context or previous step outputs, especially if it's meant to be the final user-facing response. Также используй \\`LLMStepExecutor\\` для шагов, где требуется анализ ситуации, оценка результатов предыдущих шагов, или принятие решения о дальнейшей стратегии, если это не покрывается другими инструментами.\n - FileSystemTool: Allows Orchestrator to perform file system operations within a sandboxed task-specific workspace.\n   Input ('sub_task_input'):\n     - 'operation': (String) One of [\"create_file\", \"read_file\", \"append_to_file\", \"list_files\", \"overwrite_file\", \"create_pdf_from_text\"].\n     - 'params': (Object) Parameters for the operation:\n       - create_file: { \"filename\": \"string\", \"content\": \"string\", \"directory\"?: \"string\" (optional subdirectory) }\n       - read_file: { \"filename\": \"string\", \"directory\"?: \"string\" }\n       - append_to_file: { \"filename\": \"string\", \"content\": \"string\", \"directory\"?: \"string\" } (content must be non-empty)\n       - list_files: { \"directory\"?: \"string\" (optional subdirectory relative to workspace root), \"recursive\"?: boolean (optional, default: false, if true lists recursively), \"maxDepth\"?: number (optional, default: 3 if recursive, limits recursion depth) }\n       - overwrite_file: (alias for create_file) { \"filename\": \"string\", \"content\": \"string\", \"directory\"?: \"string\" }\n       - create_pdf_from_text: { \"filename\": \"string_ending_with.pdf\", \"text_content\": \"string\", \"directory\"?: \"string\", \"fontSize\"?: number, \"fontName\"?: \"string\", \"customFontFileName\"?: \"string_ending_with.ttf_or_otf\" (e.g., \"DejaVuSans.ttf\", from 'assets/fonts/') }\n   Output: Varies by operation (e.g., success message, file content, or for list_files: Array<{path: string, type: 'file'|'directory'}> where paths are relative to task workspace root).\n   When to use: For tasks requiring intermediate data storage, reading specific files, or organizing outputs within a dedicated workspace for the current task. All paths are relative to the task's workspace root.\n - FileDownloaderTool: Allows Orchestrator to download files from a URL into the task-specific workspace.\n   Input ('sub_task_input'):\n     - 'operation': (String) Must be \"download_file\".\n     - 'params': (Object) { \"url\": \"string_url_to_download\", \"directory\"?: \"string\" (optional subdirectory), \"filename\"?: \"string\" (optional, will try to infer if not provided) }.\n   Output: Success message with path to downloaded file or error.\n   When to use: When a task requires fetching a file from an external URL for later processing or reference. Downloads are subject to size limits.\n---\n(End of available agents list and special actions)`;\n\n        const planFormatInstructions = `\nBased on the user task and available capabilities, create a multi-stage execution plan.\nThe plan MUST be a JSON array of stages. Each stage MUST be a JSON array of sub-task objects.\nSub-tasks within the same stage can be executed in parallel. Stages are executed sequentially.\nEach sub_task object in an inner array must have the following keys:\n1. 'stepId': String (A unique, non-empty identifier for this step within the plan, e.g., \"search_articles\", \"analyze_data_1\"). This ID is used for referencing outputs.\n2. 'assigned_agent_role': String (must be one of [${knownAgentRoles.map(r => `\"${r}\"`).join(\", \")}] OR \"Orchestrator\" for special actions).\n3. 'tool_name': String (must be a tool available to the assigned agent OR a special action name like \"ExploreSearchResults\", \"LLMStepExecutor\", \"FileSystemTool\", \"FileDownloaderTool\").\n4. 'sub_task_input': Object (the input for the specified tool or action).\n   - This input can reference outputs from PREVIOUSLY EXECUTED steps using the syntax \\`@{outputs.SOURCE_STEP_ID.FIELD_NAME}\\`.\n   - \\`SOURCE_STEP_ID\\` must be the 'stepId' of a step that is guaranteed to have completed (e.g., from a previous stage, or an earlier step in the same stage if execution within a stage is sequential for Orchestrator steps).\n   - \\`FIELD_NAME\\` can be 'result_data' (for the raw output of the source step) or 'processed_result_data' (for the summarized/processed output, if available; defaults to raw if not processed).\n   - Example: \\`{ \"content\": \"Summary from previous step: @{outputs.summarize_step.processed_result_data}\" }\\`\n   - For \"LLMStepExecutor\" by \"Orchestrator\", if it's the final answer, include 'isFinalAnswer: true'. It can also take an optional 'model' parameter.\n   - For \"FileSystemTool\" or \"FileDownloaderTool\", this must include 'operation' and 'params'.\n5. 'narrative_step': String (a short, human-readable description of this step's purpose).\n\nFor the 'ExploreSearchResults' action, set 'assigned_agent_role' to \"Orchestrator\" and 'tool_name' to \"ExploreSearchResults\". The 'sub_task_input' may include 'pagesToExplore' and 'relevanceCriteria'.\nFor the 'LLMStepExecutor' action by 'Orchestrator', if it's producing the final user answer, include 'isFinalAnswer: true' in 'sub_task_input'.\nFor 'FileSystemTool' and 'FileDownloaderTool' actions by 'Orchestrator', ensure 'sub_task_input' contains 'operation' and the correct 'params' for that operation.\n\nExample of a plan using FileSystemTool, stepId, and output referencing:\n\\`\\`\\`json\n[\n  [\n    {\n      \"stepId\": \"extract_info\",\n      \"assigned_agent_role\": \"Orchestrator\",\n      \"tool_name\": \"LLMStepExecutor\",\n      \"sub_task_input\": {\n        \"prompt\": \"Extract key information from the user query.\"\n      },\n      \"narrative_step\": \"Extract key information for report generation.\"\n    }\n  ],\n  [\n    {\n      \"stepId\": \"create_report_pdf\",\n      \"assigned_agent_role\": \"Orchestrator\",\n      \"tool_name\": \"FileSystemTool\",\n      \"sub_task_input\": {\n        \"operation\": \"create_pdf_from_text\",\n        \"params\": {\n          \"filename\": \"report_with_extracted_info.pdf\",\n          \"text_content\": \"Report based on: @{outputs.extract_info.result_data}\",\n          \"directory\": \"reports\",\n          \"customFontFileName\": \"DejaVuSans.ttf\"\n        }\n      },\n      \"narrative_step\": \"Create a PDF report using extracted information.\"\n    }\n  ],\n  [\n    {\n      \"stepId\": \"final_confirmation\",\n      \"assigned_agent_role\": \"Orchestrator\",\n      \"tool_name\": \"LLMStepExecutor\",\n      \"sub_task_input\": {\n        \"prompt\": \"The PDF report 'reports/report_with_extracted_info.pdf' has been created. This is the final confirmation.\",\n        \"isFinalAnswer\": true\n      },\n      \"narrative_step\": \"Confirm PDF creation and provide final status.\"\n    }\n  ]\n]\n\\`\\`\\`\n\nIMPORTANT CONSIDERATIONS FOR CONTEXT LENGTH:\n- When using tools that can return large amounts of text, such as Context7DocumentationTool, be mindful of the overall context window of subsequent LLM calls that might use this text.\n- For 'Context7DocumentationTool', if you anticipate the fetched documentation will be used directly in another LLM prompt (e.g., with LLMStepExecutor), consider specifying a 'maxTokens' value in its 'sub_task_input' (e.g., 2000 or 3000) to request a more concise version of the documentation from Context7. This helps prevent exceeding token limits in subsequent steps.\n\nProduce ONLY the JSON array of stages. Do not include any other text before or after the JSON.`;\n\n        let planningPrompt;\n        let sourcePrefix = isRevision ? \"llm_revision\" : \"llm\";\n\n        const PRINCIPLES_OF_GOOD_PLANNING = `\n---\nПринципы Качественного Планирования:\nПрежде чем генерировать JSON-план, продумай следующие аспекты:\n\n1.  **Понимание Цели**: Убедись, что ты точно понял конечную цель задачи пользователя. Если задача неясна, твой первый шаг в плане может быть направлен на уточнение задачи с помощью \\`LLMStepExecutor\\`, запросив у пользователя дополнительные детали.\n2.  **Декомпозиция**: Разбей сложную задачу на более мелкие, управляемые этапы и шаги. Каждый шаг должен иметь четкую, единственную цель.\n3.  **Логическая Последовательность и Зависимости**:\n    *   Располагай шаги в строгой логической последовательности.\n    *   Если шаг Б зависит от результата шага А, убедись, что шаг А выполняется раньше. Используй механизм ссылок \\`@{outputs.STEP_A_ID.result_data}\\` для передачи данных между шагами.\n    *   Кратко описывай зависимости в \\`narrative_step\\`, если это помогает пониманию.\n4.  **Эффективность и Оптимальность**:\n    *   Старайся достичь цели с минимально необходимым количеством шагов. Избегай избыточных или повторяющихся действий.\n    *   Выбирай наиболее подходящий инструмент для каждого шага.\n5.  **Предвидение и Обработка Ошибок (Базовый уровень)**:\n    *   Если какой-то шаг потенциально может завершиться неудачей (например, поиск информации может не дать результатов, или внешний ресурс может быть недоступен), подумай, можно ли добавить альтернативный шаг или шаг для проверки результата.\n    *   Для задач, где результат не гарантирован, план может включать шаги по информированию пользователя о невозможности выполнения или о частичных результатах.\n        *   **Полнота**: Убедись, что план покрывает все аспекты запроса пользователя, если это возможно в рамках одного плана.\n        *   **Конкретность \\`sub_task_input\\`**: Для каждого шага \\`sub_task_input\\` должен быть максимально конкретным и содержать все необходимые параметры для инструмента. Не полагайся на то, что агент \"догадается\".\n\nПомни, что хороший план — это не просто набор шагов, а логически выстроенная стратегия для решения задачи.\n---\n`;\n\n        if (isRevision) {\n            let revisionContext = `This is a replanning attempt (Attempt #${revisionAttemptNumber}) due to a failure in a previous execution.\\n`;\n            revisionContext += `Original User Task: '${userTaskString}'\\n\\n`;\n\n            if (currentCWC) { // currentCWC no longer has keyFindings or errorsEncountered directly\n                revisionContext += \"Current Working Context (CWC) Summary:\\n\";\n                revisionContext += `Overall Progress: ${currentCWC.summaryOfProgress || 'Not available.'}\\n`;\n                revisionContext += \"---\\n\";\n            }\n\n            if (latestKeyFindings && latestKeyFindings.length > 0) {\n                revisionContext += `Recent Key Findings (up to ${latestKeyFindings.length}):\n${JSON.stringify(latestKeyFindings, null, 2)}\n---\n`;\n            }\n            if (latestErrors && latestErrors.length > 0) {\n                revisionContext += `Recent Errors Encountered (up to ${latestErrors.length}):\n${JSON.stringify(latestErrors, null, 2)}\n---\n`;\n            }\n\n            if (failedStepInfo) {\n                revisionContext += \"Information about the failed step:\\n\";\n                revisionContext += `Narrative: ${failedStepInfo.narrative_step || 'N/A'}\\n`;\n                revisionContext += `Agent Role: ${failedStepInfo.assigned_agent_role || 'N/A'}\\n`;\n                revisionContext += `Tool: ${failedStepInfo.tool_name || 'N/A'}\\n`;\n                revisionContext += `Input: ${JSON.stringify(failedStepInfo.sub_task_input, null, 2)}\\n`;\n                revisionContext += `Error Message: ${failedStepInfo.errorMessage || 'N/A'}\\n`;\n                revisionContext += \"---\\n\";\n            }\n\n            if (remainingPlanStages && remainingPlanStages.length > 0) {\n                try {\n                    const remainingPlanString = JSON.stringify(remainingPlanStages, null, 2);\n                    if (remainingPlanString.length < 2000) {\n                        revisionContext += `Remaining plan stages from previous attempt:\\n${remainingPlanString}\\n---\\n`;\n                    }\n                } catch (e) { console.warn(\"PlanManager: Could not stringify remainingPlanStages for revision prompt.\"); }\n            }\n\n            if (executionContextSoFar && executionContextSoFar.length > 0) {\n                try {\n                    const recentContextString = JSON.stringify(executionContextSoFar.slice(-3), null, 2);\n                    revisionContext += `Recent execution context (last 3-5 steps/results):\\n${recentContextString}\\n---\\n`;\n                } catch (e) { console.warn(\"PlanManager: Could not stringify executionContextSoFar for revision prompt.\"); }\n            }\n\n            revisionContext += `Instruction: Given all the information above (original task, capabilities, previous attempt's failure, context, and remaining plan if any), generate a revised plan to achieve the user's objective. You can modify the remaining plan, create a completely new plan, or decide if the task is unachievable. If the task seems unachievable or you cannot devise a recovery plan, return an empty JSON array [] or a plan with a single step explaining why it's not possible using LLMStepExecutor with isFinalAnswer: true.\nТвой новый план должен:\nа) Учитывать причину предыдущего сбоя (из 'Information about the failed step').\nб) Предложить конкретные изменения или альтернативные шаги для обхода проблемы.\nв) Если проблема не в конкретном шаге, а в общей стратегии, пересмотреть стратегию.\nг) Если предыдущие шаги (из 'Recent execution context') дали полезные результаты, старайся их использовать в новом плане, чтобы не делать лишнюю работу.\nд) Если задача действительно невыполнима даже после нескольких попыток, четко объясни это в финальном шаге через \\`LLMStepExecutor\\` с \\`isFinalAnswer: true\\`. Не зацикливайся на создании неработающих планов.`;\n\n            // New approach for revision:\n            let fullRevisionPromptBase;\n            // If megaContext is available, use it as the primary source of information for replanning.\n            // It contains a comprehensive snapshot of the task state (task def, uploaded files, findings, etc.).\n            // The existing revisionContext (failed step details, recent CWC, etc.) is appended to it.\n            if (memoryContext && memoryContext.megaContext && typeof memoryContext.megaContext === 'string' && memoryContext.megaContext.trim() !== '') {\n                fullRevisionPromptBase = `${memoryContext.megaContext}\n\n${revisionContext}`; // Append specific revision details to the general megaContext.\n                sourcePrefix += \"_with_megacontext\"; // Indicate megaContext was used for logging/tracking.\n            } else {\n                // Fallback: If megaContext is not available, use the older method of combining\n                // revisionContext with memoryContextPromptSection (summarized decisions, CWC snapshot).\n                fullRevisionPromptBase = `${revisionContext}${memoryContextPromptSection}`;\n            }\n            planningPrompt = `${fullRevisionPromptBase}\n${PRINCIPLES_OF_GOOD_PLANNING}\n\nAvailable agent capabilities:\n---\n${formattedAgentCapabilitiesString}\n---\n${orchestratorSpecialActionsDescription}\n---\n${planFormatInstructions}`;\n\n        } else {\n            // Logic for initial planning\n            // Check if a pre-assembled megaContext is provided in memoryContext.\n            if (memoryContext && memoryContext.megaContext && typeof memoryContext.megaContext === 'string' && memoryContext.megaContext.trim() !== '') {\n                // If megaContext exists, it becomes the primary informational base for the planning prompt.\n                // It should already contain task definition, uploaded files, key findings, etc.\n                // We then append the userTaskString explicitly for emphasis, followed by standard planning instructions.\n                planningPrompt = `${memoryContext.megaContext}\n\nUser Task (ensure this is addressed by the plan): '${userTaskString}'\n${PRINCIPLES_OF_GOOD_PLANNING}\n\nAvailable agent capabilities:\n---\n${formattedAgentCapabilitiesString}\n---\n${orchestratorSpecialActionsDescription}\n---\n${planFormatInstructions}`;\n                sourcePrefix += \"_with_megacontext\"; // Update source prefix for tracking.\n            } else {\n                // Fallback to the original logic if megaContext is not available.\n                // This constructs the prompt from individual pieces like initialPromptSection (user task)\n                // and memoryContextPromptSection (summarized decisions, CWC snapshot).\n                planningPrompt = `${initialPromptSection}${memoryContextPromptSection}\n${PRINCIPLES_OF_GOOD_PLANNING}\n\nAvailable agent capabilities:\n---\n${formattedAgentCapabilitiesString}\n---\n${orchestratorSpecialActionsDescription}\n---\n${planFormatInstructions}`;\n            }\n        }\n\n        let planJsonString;\n        let llmCallPrompt = planningPrompt; // Start with the fully constructed prompt\n\n        // Determine the model for the LLM call, defaulting appropriately for Gemini or other services.\n        let defaultModelForService = 'gpt-4'; // General default\n        if (this.aiService.getServiceName && this.aiService.getServiceName() === 'GeminiService') {\n            defaultModelForService = 'gemini-1.5-pro-latest'; // Gemini specific default\n        }\n        const llmCallParams = {\n            model: (this.aiService.baseConfig && this.aiService.baseConfig.planningModel) || defaultModelForService\n        };\n\n        // Check if running with GeminiService and if OrchestratorAgent has prepared a CachedContent.\n        if (this.aiService.getServiceName && this.aiService.getServiceName() === 'GeminiService' &&\n            memoryContext && memoryContext.isMegaContextCachedByGemini === true &&\n            memoryContext.geminiCachedContentName) {\n\n            console.log(`PlanManager: Gemini CachedContent (Name: ${memoryContext.geminiCachedContentName}) found. Using short prompt for planning.`);\n\n            if (isRevision) {\n                // For revisions, the prompt needs to instruct the LLM to use the cached context\n                // while also considering the revision-specific details (failure, CWC, etc.).\n                // The 'revisionContext' variable already contains much of this, excluding the full megaContext.\n                // We assume 'userTaskString' is the most direct representation of the overall goal.\n                llmCallPrompt = `Original User Task: '${userTaskString}'.\nThis is a replanning attempt (Attempt #${revisionAttemptNumber}).\nDetailed context including previous attempt's failure, execution history, CWC, key findings, and errors has been provided in the cached content.\nInstruction: Based on ALL available information (original task, cached context, and the specific details of the previous failure), generate a revised plan.\n${PRINCIPLES_OF_GOOD_PLANNING}\nAvailable agent capabilities:\n---\n${formattedAgentCapabilitiesString}\n---\n${orchestratorSpecialActionsDescription}\n---\n${planFormatInstructions}`;\n            } else {\n                // For initial planning with cached content.\n                llmCallPrompt = `User Task: '${userTaskString}'.\nThe necessary context (task definition, uploaded files, key findings, chat history) has been provided and is cached.\n${PRINCIPLES_OF_GOOD_PLANNING}\nAvailable agent capabilities:\n---\n${formattedAgentCapabilitiesString}\n---\n${orchestratorSpecialActionsDescription}\n---\n${planFormatInstructions}\nBased on the cached context and the user task, generate a plan.`;\n            }\n\n            llmCallParams.cachedContentName = memoryContext.geminiCachedContentName;\n            // sourcePrefix might already include \"_with_megacontext\" from earlier logic if megaContext string was present.\n            // This is acceptable as it indicates rich context was available, now via cache.\n        }\n        // If not using Gemini cache, llmCallPrompt remains the original long planningPrompt,\n        // and llmCallParams does not include cachedContentName.\n\n        try {\n            planJsonString = await this.aiService.generateText(llmCallPrompt, llmCallParams);\n        } catch (llmError) {\n            console.error(`PlanManager: Error from AI service during ${sourcePrefix} planning:`, llmError.message);\n            return { success: false, message: `Failed to generate plan due to AI service error: ${llmError.message}`, source: `${sourcePrefix}_service_error`, rawResponse: null };\n        }\n\n        const validationResult = await this.parseAndValidatePlan(planJsonString, knownAgentRoles, knownToolsByRole);\n        if (!validationResult.success) {\n            return { success: false, message: validationResult.message, source: `${sourcePrefix}_validation_error`, rawResponse: validationResult.rawResponse };\n        }\n\n        return { success: true, plan: validationResult.stages, source: sourcePrefix, rawResponse: validationResult.rawResponse };\n    }\n}\n\nmodule.exports = PlanManager;\n","usedDeprecatedRules":[{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/app/core/ResultsQueue.js","messages":[],"suppressedMessages":[{"ruleId":"security/detect-object-injection","severity":1,"message":"Variable Assigned to Object Injection Sink","line":68,"column":39,"nodeType":"MemberExpression","endLine":68,"endColumn":66,"suppressions":[{"kind":"directive","justification":"resultKey is parentTaskId (a system-generated UUID)."}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":71,"column":23,"nodeType":"MemberExpression","endLine":71,"endColumn":50,"suppressions":[{"kind":"directive","justification":"resultKey is parentTaskId (a system-generated UUID), used for deletion."}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":83,"column":8,"nodeType":"MemberExpression","endLine":83,"endColumn":35,"suppressions":[{"kind":"directive","justification":"resultKey is parentTaskId (a system-generated UUID)."}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/app/core/SubTaskQueue.js","messages":[],"suppressedMessages":[{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":16,"column":80,"nodeType":"MemberExpression","endLine":16,"endColumn":106,"suppressions":[{"kind":"directive","justification":"'role' is from taskMessage, expected to be a known agent role string."}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":16,"column":110,"nodeType":"MemberExpression","endLine":16,"endColumn":136,"suppressions":[{"kind":"directive","justification":"'role' is from taskMessage, expected to be a known agent role string."}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":35,"column":11,"nodeType":"MemberExpression","endLine":35,"endColumn":42,"suppressions":[{"kind":"directive","justification":"agentRole is a string provided by system components (Agents), considered safe."}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":40,"column":11,"nodeType":"MemberExpression","endLine":40,"endColumn":42,"suppressions":[{"kind":"directive","justification":"agentRole is a system-provided string, considered safe."}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":46,"column":7,"nodeType":"MemberExpression","endLine":46,"endColumn":38,"suppressions":[{"kind":"directive","justification":"agentRole is a system-provided string, considered safe."}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":49,"column":103,"nodeType":"MemberExpression","endLine":49,"endColumn":134,"suppressions":[{"kind":"directive","justification":"agentRole is a system-provided string, considered safe."}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/app/core/dependencies.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/app/core/websocketHandler.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/app/index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/app/routes/apiRoutes.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/app/services/BaseAIService.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/app/services/Context7Client.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/app/services/Context7Client.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/app/services/ai/AnthropicAPIService.js","messages":[],"suppressedMessages":[{"ruleId":"security/detect-object-injection","severity":1,"message":"Variable Assigned to Object Injection Sink","line":187,"column":27,"nodeType":"MemberExpression","endLine":187,"endColumn":70,"suppressions":[{"kind":"directive","justification":"currentModelForContext is derived from baseConfig or validated against allowedModels."}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/app/services/ai/BaseAIService.js","messages":[],"suppressedMessages":[{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":52,"column":16,"nodeType":"MemberExpression","endLine":52,"endColumn":44,"suppressions":[{"kind":"directive","justification":"currentModel is from baseConfig, assumed to be safe. modelMaxTokens is also from baseConfig."}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/app/services/ai/GeminiService.js","messages":[],"suppressedMessages":[{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":294,"column":30,"nodeType":"MemberExpression","endLine":294,"endColumn":73,"suppressions":[{"kind":"directive","justification":"currentModelForContext is derived from baseConfig (assumed safe) or validated against allowedModels."}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/app/services/ai/GeminiService.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/app/services/ai/OpenAIService.js","messages":[],"suppressedMessages":[{"ruleId":"security/detect-object-injection","severity":1,"message":"Variable Assigned to Object Injection Sink","line":209,"column":27,"nodeType":"MemberExpression","endLine":209,"endColumn":70,"suppressions":[{"kind":"directive","justification":"currentModelForContext is derived from baseConfig (assumed safe) or validated against allowedModels."}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":214,"column":27,"nodeType":"MemberExpression","endLine":214,"endColumn":57,"suppressions":[{"kind":"directive","justification":"baseModel is derived from currentModelForContext (which is validated/safe) and used to access a known map."}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/app/services/ai/OpenAIService.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/app/tools/CalculatorTool.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/app/tools/Context7DocumentationTool.js","messages":[],"suppressedMessages":[{"ruleId":"no-unused-vars","severity":1,"message":"'Context7Client' is assigned a value but never used.","line":4,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":4,"endColumn":21,"suppressions":[{"kind":"directive","justification":"Used in constructor for instanceof check and type validation"}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/app/tools/Context7DocumentationTool.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/app/tools/FileDownloaderTool.js","messages":[],"suppressedMessages":[{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":16,"column":14,"nodeType":"CallExpression","endLine":16,"endColumn":50,"suppressions":[{"kind":"directive","justification":"taskWorkspaceDir is resolved from a constructor argument, expected to be a safe base path."}]},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found mkdirSync from package \"fs\" with non literal argument at index 0","line":18,"column":13,"nodeType":"CallExpression","endLine":18,"endColumn":69,"suppressions":[{"kind":"directive","justification":"taskWorkspaceDir is resolved from a constructor argument, expected to be a safe base path."}]},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found mkdir from package \"fs\" with non literal argument at index 0","line":50,"column":15,"nodeType":"CallExpression","endLine":50,"endColumn":58,"suppressions":[{"kind":"directive","justification":"dirToEnsure is derived from a sanitized and validated path."}]},{"ruleId":"no-control-regex","severity":2,"message":"Unexpected control character(s) in regular expression: \\x1f.","line":57,"column":42,"nodeType":"Literal","messageId":"unexpected","endLine":57,"endColumn":63,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found stat from package \"fs\" with non literal argument at index 0","line":135,"column":59,"nodeType":"CallExpression","endLine":135,"endColumn":81,"suppressions":[{"kind":"directive","justification":"safeFilePath is sanitized by _getSafePath."}]},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found createWriteStream from package \"fs\" with non literal argument at index 0","line":142,"column":28,"nodeType":"CallExpression","endLine":142,"endColumn":62,"suppressions":[{"kind":"directive","justification":"safeFilePath is sanitized by _getSafePath."}]},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found unlink from package \"fs\" with non literal argument at index 0","line":156,"column":33,"nodeType":"CallExpression","endLine":156,"endColumn":57,"suppressions":[{"kind":"directive","justification":"safeFilePath is sanitized by _getSafePath."}]},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found unlink from package \"fs\" with non literal argument at index 0","line":168,"column":26,"nodeType":"CallExpression","endLine":168,"endColumn":50,"suppressions":[{"kind":"directive","justification":"safeFilePath is sanitized by _getSafePath"}]},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found unlink from package \"fs\" with non literal argument at index 0","line":181,"column":25,"nodeType":"CallExpression","endLine":181,"endColumn":49,"suppressions":[{"kind":"directive","justification":"safeFilePath is sanitized by _getSafePath."}]},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found unlink from package \"fs\" with non literal argument at index 0","line":193,"column":21,"nodeType":"CallExpression","endLine":193,"endColumn":45,"suppressions":[{"kind":"directive","justification":"safeFilePath is sanitized by _getSafePath."}]},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found unlink from package \"fs\" with non literal argument at index 0","line":200,"column":21,"nodeType":"CallExpression","endLine":200,"endColumn":45,"suppressions":[{"kind":"directive","justification":"safeFilePath is sanitized by _getSafePath."}]},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found unlink from package \"fs\" with non literal argument at index 0","line":210,"column":29,"nodeType":"CallExpression","endLine":210,"endColumn":53,"suppressions":[{"kind":"directive","justification":"safeFilePath is sanitized by _getSafePath."}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/app/tools/FileSystemTool.js","messages":[],"suppressedMessages":[{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found mkdir from package \"fs\" with non literal argument at index 0","line":19,"column":9,"nodeType":"CallExpression","endLine":19,"endColumn":62,"suppressions":[{"kind":"directive","justification":"taskWorkspaceDir is resolved from a constructor argument, expected to be a safe base path."}]},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found stat from package \"fs\" with non literal argument at index 0","line":57,"column":37,"nodeType":"CallExpression","endLine":57,"endColumn":59,"suppressions":[{"kind":"directive","justification":"resolvedPath is constructed from sanitized components and validated against workspaceDir."}]},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found mkdir from package \"fs\" with non literal argument at index 0","line":75,"column":15,"nodeType":"CallExpression","endLine":75,"endColumn":58,"suppressions":[{"kind":"directive","justification":"dirToEnsure is derived from a sanitized and validated path."}]},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found stat from package \"fs\" with non literal argument at index 0","line":92,"column":37,"nodeType":"CallExpression","endLine":92,"endColumn":59,"suppressions":[{"kind":"directive","justification":"safeFilePath is sanitized by _getSafePath."}]},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found writeFile from package \"fs\" with non literal argument at index 0","line":100,"column":19,"nodeType":"CallExpression","endLine":100,"endColumn":70,"suppressions":[{"kind":"directive","justification":"safeFilePath is sanitized by _getSafePath."}]},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found stat from package \"fs\" with non literal argument at index 0","line":121,"column":33,"nodeType":"CallExpression","endLine":121,"endColumn":55,"suppressions":[{"kind":"directive","justification":"safeFilePath is sanitized by _getSafePath."}]},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found readFile from package \"fs\" with non literal argument at index 0","line":130,"column":35,"nodeType":"CallExpression","endLine":130,"endColumn":69,"suppressions":[{"kind":"directive","justification":"safeFilePath is sanitized by _getSafePath."}]},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found stat from package \"fs\" with non literal argument at index 0","line":159,"column":37,"nodeType":"CallExpression","endLine":159,"endColumn":59,"suppressions":[{"kind":"directive","justification":"safeFilePath is sanitized by _getSafePath."}]},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found appendFile from package \"fs\" with non literal argument at index 0","line":168,"column":19,"nodeType":"CallExpression","endLine":168,"endColumn":71,"suppressions":[{"kind":"directive","justification":"safeFilePath is sanitized by _getSafePath."}]},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found readdir from package \"fs\" with non literal argument at index 0","line":186,"column":35,"nodeType":"CallExpression","endLine":186,"endColumn":90,"suppressions":[{"kind":"directive","justification":"fullDirectoryPath is recursively built from sanitized initial paths and checked."}]},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found stat from package \"fs\" with non literal argument at index 0","line":235,"column":37,"nodeType":"CallExpression","endLine":235,"endColumn":64,"suppressions":[{"kind":"directive","justification":"safeTargetDirPath is already sanitized by _getSafePath."}]},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found readdir from package \"fs\" with non literal argument at index 0","line":263,"column":39,"nodeType":"CallExpression","endLine":263,"endColumn":94,"suppressions":[{"kind":"directive","justification":"safeTargetDirPath is sanitized by _getSafePath."}]},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found stat from package \"fs\" with non literal argument at index 0","line":309,"column":37,"nodeType":"CallExpression","endLine":309,"endColumn":59,"suppressions":[{"kind":"directive","justification":"safeFilePath is sanitized by _getSafePath."}]},{"ruleId":"no-async-promise-executor","severity":2,"message":"Promise executor functions should not be async.","line":321,"column":32,"nodeType":"Identifier","messageId":"async","endLine":321,"endColumn":37,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found createWriteStream from package \"fs\" with non literal argument at index 0","line":329,"column":32,"nodeType":"CallExpression","endLine":329,"endColumn":66,"suppressions":[{"kind":"directive","justification":"safeFilePath is sanitized by _getSafePath."}]},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found unlink from package \"fs\" with non literal argument at index 0","line":380,"column":21,"nodeType":"CallExpression","endLine":380,"endColumn":45,"suppressions":[{"kind":"directive","justification":"safeFilePath is sanitized by _getSafePath."}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/app/tools/ReadWebpageTool.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/app/tools/WebSearchTool.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/app/utils/localization.js","messages":[],"suppressedMessages":[{"ruleId":"node/no-unsupported-features/es-syntax","severity":2,"message":"'import()' expressions are not supported yet.","line":17,"column":38,"nodeType":"ImportExpression","messageId":"no-dynamic-import","endLine":17,"endColumn":57,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"node/no-missing-import","severity":2,"message":"\"os-locale\" is not found.","line":17,"column":45,"nodeType":"Literal","endLine":17,"endColumn":56,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":42,"column":10,"nodeType":"MemberExpression","endLine":42,"endColumn":37,"suppressions":[{"kind":"directive","justification":"currentLocale is sanitized."}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":49,"column":10,"nodeType":"MemberExpression","endLine":49,"endColumn":37,"suppressions":[{"kind":"directive","justification":"currentLocale is sanitized."}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":52,"column":10,"nodeType":"MemberExpression","endLine":52,"endColumn":37,"suppressions":[{"kind":"directive","justification":"currentLocale is sanitized."}]},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found readFile from package \"fs\" with non literal argument at index 0","line":60,"column":28,"nodeType":"CallExpression","endLine":60,"endColumn":57,"suppressions":[{"kind":"directive","justification":"locale component is sanitized in initializeLocalization."}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":62,"column":9,"nodeType":"MemberExpression","endLine":62,"endColumn":29,"suppressions":[{"kind":"directive","justification":"locale is a sanitized string."}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":69,"column":9,"nodeType":"MemberExpression","endLine":69,"endColumn":29,"suppressions":[{"kind":"directive","justification":"locale is a sanitized string."}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":75,"column":38,"nodeType":"MemberExpression","endLine":75,"endColumn":65,"suppressions":[{"kind":"directive","justification":"currentLocale is sanitized; 'en' is a string literal."}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":79,"column":19,"nodeType":"MemberExpression","endLine":79,"endColumn":48,"suppressions":[{"kind":"directive","justification":"key is a developer-provided string literal. langSpecificTranslations is from a controlled source."}]},{"ruleId":"security/detect-non-literal-regexp","severity":1,"message":"Found non-literal argument to RegExp Constructor","line":97,"column":37,"nodeType":"NewExpression","endLine":97,"endColumn":76,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Function Call Object Injection Sink","line":99,"column":63,"nodeType":"MemberExpression","endLine":99,"endColumn":75,"suppressions":[{"kind":"directive","justification":"'argKey' is from 'args' object, existence checked by hasOwnProperty. Value used for string replacement."}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/app/utils/taskPathUtils.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/app/utils/taskStateUtil.js","messages":[],"suppressedMessages":[{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found mkdir from package \"fs\" with non literal argument at index 0","line":17,"column":15,"nodeType":"CallExpression","endLine":17,"endColumn":62,"suppressions":[{"kind":"directive","justification":"filePath (and thus dirname) is expected to be constructed safely by the caller using system-generated IDs and base paths."}]},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found writeFile from package \"fs\" with non literal argument at index 0","line":27,"column":15,"nodeType":"CallExpression","endLine":27,"endColumn":64,"suppressions":[{"kind":"directive","justification":"filePath is expected to be constructed safely by the caller."}]},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found readFile from package \"fs\" with non literal argument at index 0","line":55,"column":32,"nodeType":"CallExpression","endLine":55,"endColumn":70,"suppressions":[{"kind":"directive","justification":"filePath is expected to be constructed safely by the caller."}]},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found mkdir from package \"fs\" with non literal argument at index 0","line":87,"column":15,"nodeType":"CallExpression","endLine":87,"endColumn":66,"suppressions":[{"kind":"directive","justification":"dateDirPath is constructed from a configured base path and system-generated date."}]},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found writeFile from package \"fs\" with non literal argument at index 0","line":97,"column":15,"nodeType":"CallExpression","endLine":97,"endColumn":65,"suppressions":[{"kind":"directive","justification":"filePath is constructed from a configured base path, system date, and system-generated parentTaskId."}]},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found readdir from package \"fs\" with non literal argument at index 0","line":129,"column":34,"nodeType":"CallExpression","endLine":129,"endColumn":92,"suppressions":[{"kind":"directive","justification":"tasksBaseDir is a configured, trusted base path."}]},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found readFile from package \"fs\" with non literal argument at index 0","line":153,"column":35,"nodeType":"CallExpression","endLine":153,"endColumn":78,"suppressions":[{"kind":"directive","justification":"foundFilePath is determined by searching for system-generated filenames within controlled subdirectories."}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]}]