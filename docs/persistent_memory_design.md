# Conceptual Design: Persistent Task Memory

## 1. Overview

This document outlines a conceptual design for a persistent task memory system for the AI agent. The goal is to save the state, history, and outcomes of each task processed by the agent to the file system. This persisted memory will facilitate debugging, review, analysis of agent performance, and could enable future capabilities like task resumption or learning from past executions. This design is conceptual and does not involve immediate code implementation.

## 2. Key Information to Persist

The following key pieces of information should be persisted for each task:

*   **`parentTaskId`**: Unique ID for the overall user task.
*   **`originalUserTask`**: The verbatim task string from the user.
*   **`taskStatus`**: Current or final status (e.g., "RECEIVED", "PLANNING", "EXECUTING_PLAN", "SYNTHESIZING_ANSWER", "COMPLETED_SUCCESS", "FAILED_PLANNING", "FAILED_EXECUTION", "FAILED_SYNTHESIS", "FAILED_REPLANNING_NO_RECOVERY_PLAN", "FAILED_RECOVERY_EXECUTION").
*   **`timestamps`**:
    *   `createdAt`: When the task was first received.
    *   `planGeneratedAt`: When the initial plan was successfully generated.
    *   `executionStartedAt`: When plan execution began.
    *   `synthesisStartedAt`: When final answer synthesis began.
    *   `completedAt`: When the task reached a final state.
    *   `lastUpdatedAt`: Timestamp of the last memory modification for this task.
*   **`generatedPlan`**: The full plan structure (stages and steps) as generated by the LLM planner (via `PlanManager`).
*   **`executionContext`**: An array detailing each executed step, its inputs, status, and results (both raw and processed/summarized). This is a primary output from `PlanExecutor`.
*   **`currentWorkingContext`**: A JSON object stored within the main task state file (e.g., `task_state_{taskId}.json`). This object is dynamically updated throughout the task lifecycle and provides a live summary and evolving understanding of the task. Its fields include:
    *   `lastUpdatedAt` (string, ISO8601): Timestamp of the last CWC update.
    *   `summaryOfProgress` (string): A human-readable summary of the current task progress and agent's understanding. This field is initially set programmatically and can then be refined by an LLM call within `OrchestratorAgent` based on recent findings and errors.
    *   `keyFindings` (array of objects): Important pieces of information extracted from successful tool executions. Each object might contain:
        *   `findingId` (string, UUID): Unique ID for the finding.
        *   `sourceStepNarrative` (string): Narrative of the step that produced the finding.
        *   `sourceToolName` (string): Name of the tool that produced the finding.
        *   `data` (any): The extracted information (can be string, object, etc., possibly truncated for brevity).
        *   `timestamp` (string, ISO8601): When the finding was recorded.
    *   `identifiedEntities` (object): Key-value pairs of entities identified during the task (e.g., names, locations, concepts). (Future use, populated by NLP tools or LLM analysis).
    *   `pendingQuestions` (array of strings): Questions the agent has identified that need answering to fulfill the user's request. (Future use, for more complex reasoning or interactive tasks).
    *   `nextObjective` (string): The agent's understanding of what it should do next. This field is initially set programmatically and can then be refined by an LLM call within `OrchestratorAgent` to suggest a more contextually relevant next step.
    *   `confidenceScore` (number, 0.0-1.0): The agent's current confidence in its ability to meet the user's goal. (Future use).
    *   `errorsEncountered` (array of objects): A list of errors encountered during execution. Each object might contain:
        *   `errorId` (string, UUID): Unique ID for the error instance.
        *   `sourceStepNarrative` (string): Narrative of the step that failed.
        *   `sourceToolName` (string): Name of the tool that failed.
        *   `errorMessage` (string): The error message.
        *   `timestamp` (string, ISO8601): When the error was recorded.
*   **`TaskJournal`**: A detailed, append-only log of all significant events and state changes during the task lifecycle, stored in a separate `task_journal_{parentTaskId}.jsonl` file. Each line is a JSON object representing a journal entry. Entries include:
    *   `timestamp` (string, ISO8601): Time of the event.
    *   `type` (string): Type of the event (e.g., "TASK_RECEIVED", "PLANNING_STARTED", "EXECUTION_STEP_DISPATCHED", "CWC_UPDATED", "FINAL_SYNTHESIS_FAILED").
    *   `source` (string): Originator of the event (e.g., "OrchestratorAgent", "PlanManager", "PlanExecutor").
    *   `message` (string): Human-readable description of the event.
    *   `details` (object): Any relevant data associated with the event (e.g., step details, error messages, CWC summary).
*   **`finalAnswer`**: The final, synthesized answer provided to the user.
*   **`errorSummary` (if task failed overall):** Details of the critical failure.

## 3. Directory and File Structure

A structured directory and file layout is proposed for clarity and ease of access.

*   **Main Memory Directory:**
    *   A top-level directory: `task_memory_bank/` (to be added to `.gitignore`).
*   **Individual Task Memory Directory:**
    *   Inside `task_memory_bank/`, each task has a subdirectory named by its `parentTaskId`:
        *   Example: `task_memory_bank/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/`
*   **Files within Each Task's Directory:**
    *   **`task_state_{taskId}.json`**: Stores `parentTaskId`, `originalUserTask`, `taskStatus`, all relevant `timestamps`, `finalAnswer` (directly or as a reference), `errorSummary`, the `generatedPlan`, `executionContext`, and the `currentWorkingContext` object.
    *   **`task_journal_{parentTaskId}.jsonl`**: Append-only log of all significant events (TaskJournal entries), each line a JSON object.
    *   No separate `plan.json` or `final_answer.md` by default, this information is consolidated into `task_state_{taskId}.json` or directly within the journal/context where appropriate. The `context_history/` directory is also removed in favor of `CurrentWorkingContext` and `TaskJournal`.

**Example Structure:**
```
saved_tasks/
└── tasks_MMDDYYYY/
    └── task_state_xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx.json  (parentTaskId)
    └── task_journal_xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx.jsonl (parentTaskId)
```

## 4. Content Schema for Key Files

*   **`task_state_{taskId}.json` (JSON Object):**
    ```json
    {
      "taskId": "string_uuid", // Was parentTaskId
      "userTaskString": "string",
      "status": "string", // e.g., "COMPLETED", "FAILED_PLANNING", "FAILED_EXECUTION"
      "createdAt": "ISO8601_datetime_string",
      "updatedAt": "ISO8601_datetime_string",
      // Other timestamps like planGeneratedAt, executionStartedAt can be added if needed,
      // or inferred from TaskJournal.
      "plan": [], // Array of stage objects as generated by PlanManager
      "plan_source": "string_or_null", // "template" or "LLM"
      "raw_llm_response": "string_or_null", // Raw LLM plan string if applicable
      "executionContext": [], // Array of ContextEntry objects from PlanExecutor
      "finalAnswer": "string_or_null",
      "errorSummary": { // Present if taskStatus indicates failure
        "reason": "string_or_null",
        "failedStepId": "string_or_null"
      },
      "currentWorkingContext": {
        "lastUpdatedAt": "ISO8601_datetime_string",
        "summaryOfProgress": "string", // Can be updated by LLM
        "keyFindings": [
          {
            "findingId": "string_uuid",
            "sourceStepNarrative": "string",
            "sourceToolName": "string",
            "data": "any", // Potentially truncated
            "timestamp": "ISO8601_datetime_string"
          }
        ],
        "identifiedEntities": {},
        "pendingQuestions": [],
        "nextObjective": "string", // Can be updated by LLM
        "confidenceScore": 0.0,
        "errorsEncountered": [
          {
            "errorId": "string_uuid",
            "sourceStepNarrative": "string",
            "sourceToolName": "string",
            "errorMessage": "string",
            "timestamp": "ISO8601_datetime_string"
          }
        ]
      },
      "version": "1.1" // Schema version updated
    }
    ```

*   **`task_journal_{parentTaskId}.jsonl` (Each line is a JSON Object):**
    ```json
    {
      "timestamp": "ISO8601_datetime_string",
      "type": "string", // e.g., "TASK_RECEIVED", "PLANNING_STARTED", "EXECUTION_STEP_DISPATCHED"
      "source": "string", // e.g., "OrchestratorAgent", "PlanManager", "PlanExecutor"
      "message": "string",
      "details": {} // Object with event-specific details
    }
    ```

## 5. Agent Interaction Logic (Conceptual - When to Save)

The `OrchestratorAgent` is primarily responsible for managing the lifecycle of task state, CWC, and journal.

*   **Task Reception (`handleUserTask` start):**
    *   `parentTaskId` is received or generated.
    *   Initialize `currentWorkingContext` (CWC).
    *   Initialize `finalJournalEntries` array, add `TASK_RECEIVED` and `CWC_INITIALIZED` entries.
*   **Planning Phase (interaction with `PlanManager`):**
    *   Log `PLANNING_STARTED` to journal.
    *   `PlanManager.getPlan()` is called.
    *   Log `PLANNING_COMPLETED` or `PLANNING_FAILED` to journal.
    *   If planning fails: update CWC with error, save `task_state_{...}.json` (including CWC, status "FAILED_PLANNING"), save `task_journal_{...}.jsonl`, and return.
    *   If `PLAN_ONLY` mode: update CWC, save `task_state_{...}.json` (including CWC, plan, status "PLAN_GENERATED"), log final status to journal, save `task_journal_{...}.jsonl`, and return.
*   **Execution Phase (interaction with `PlanExecutor`):**
    *   Log `EXECUTION_STARTED` to journal. Update CWC.
    *   `PlanExecutor.executePlan()` is called. This method internally generates many journal entries related to stage/step start, dispatch, results, completion, failure, and data summarization. It also collects `keyFindings` and `errorsEncountered`.
    *   `OrchestratorAgent` receives `success`, `executionContext`, `journalEntries` (from executor), and `updatesForWorkingContext` from `PlanExecutor`.
    *   Merge executor's journal entries into `finalJournalEntries`.
    *   Log `EXECUTION_COMPLETED` or `EXECUTION_FAILED` to `finalJournalEntries`.
    *   Update local `currentWorkingContext` with `keyFindings` and `errorsEncountered` from `updatesForWorkingContext`. Programmatically set a basic `summaryOfProgress` and `nextObjective`.
    *   **CWC Refinement by LLM:** `OrchestratorAgent` then makes an LLM call with the current CWC data (recent findings, errors, previous summary/objective) to generate more insightful `summaryOfProgress` and `nextObjective`. The CWC is updated with these LLM-generated values. This is logged in the journal (`CWC_UPDATE_LLM_START`, `CWC_UPDATED_BY_LLM` or `CWC_UPDATE_LLM_ERROR`).
*   **Final Synthesis Phase:**
    *   Log `FINAL_SYNTHESIS_START` to journal.
    *   Construct synthesis prompt including stringified CWC.
    *   Call LLM service.
    *   Log `FINAL_SYNTHESIS_SUCCESS`, `_FAILED`, or `_SKIPPED` to journal. Update CWC.
*   **Final Save (end of `handleUserTask` or in `catch` block):**
    *   Log final task status (`TASK_COMPLETED_SUCCESSFULLY` or `TASK_FAILED_FINAL`) to `finalJournalEntries`.
    *   Save the complete `task_state_{...}.json` (including the final CWC, `executionContext`, `finalAnswer`, etc.).
    *   Save the complete `task_journal_{...}.jsonl` with all accumulated entries.
*   **Loading State (`SYNTHESIZE_ONLY`, `EXECUTE_PLANNED_TASK`):**
    *   `loadTaskState` is used to get the main state file.
    *   If `currentWorkingContext` exists in the loaded state, it's used.
    *   `loadTaskJournal` can be used to retrieve the history if needed for context or review (though not directly used for re-synthesis by default).
```
