# Conceptual Design: Persistent Task Memory

## 1. Overview

This document outlines a conceptual design for a persistent task memory system for the AI agent. The goal is to save the state, history, and outcomes of each task processed by the agent to the file system. This persisted memory will facilitate debugging, review, analysis of agent performance, and could enable future capabilities like task resumption or learning from past executions. This design is conceptual and does not involve immediate code implementation.

## 2. Key Information to Persist

The following key pieces of information should be persisted for each task:

*   **`parentTaskId`**: Unique ID for the overall user task.
*   **`originalUserTask`**: The verbatim task string from the user.
*   **`taskStatus`**: Current or final status (e.g., "RECEIVED", "PLANNING", "EXECUTING_PLAN", "SYNTHESIZING_ANSWER", "COMPLETED_SUCCESS", "FAILED_PLANNING", "FAILED_EXECUTION", "FAILED_SYNTHESIS", "FAILED_REPLANNING_NO_RECOVERY_PLAN", "FAILED_RECOVERY_EXECUTION").
*   **`timestamps`**:
    *   `createdAt`: When the task was first received.
    *   `planGeneratedAt`: When the initial plan was successfully generated.
    *   `executionStartedAt`: When plan execution began.
    *   `synthesisStartedAt`: When final answer synthesis began.
    *   `completedAt`: When the task reached a final state.
    *   `lastUpdatedAt`: Timestamp of the last memory modification for this task.
*   **`generatedPlan`**: The full plan structure (stages and steps) as generated by the LLM planner, including `stage`, `stepDescription`, `toolName`, `sub_task_input`, and `narrative_step` for each step.
*   **`executionLog`**: A detailed, ordered log of all execution events (step execution, system actions like context summarization or replanning, successes, failures). Each entry should include:
    *   `timestamp`, `stage`, `sub_task_id` (if applicable), `step_narrative` (or system action description), `tool_name` (or "System"), `status`, `input_payload` (optional), `resultData` (if applicable), `errorInfo` (if applicable), `duration_ms` (optional).
*   **`contextHistory`**: Snapshots of the `contextSummaryForNextStep` string at various key points (e.g., initial, before/after summarization, before stages). Each snapshot includes a `timestamp`, an identifier for when it was taken, the `contextContent` string, and an `isSummarized` flag.
*   **`finalAnswer`**: The final, synthesized answer provided to the user.
*   **`errorSummary` (if task failed):** Details of the critical failure, including `failedAtStage`, `failedStepNarrative`, and `errorMessage`.

## 3. Directory and File Structure

A structured directory and file layout is proposed for clarity and ease of access.

*   **Main Memory Directory:**
    *   A top-level directory: `task_memory_bank/` (to be added to `.gitignore`).
*   **Individual Task Memory Directory:**
    *   Inside `task_memory_bank/`, each task has a subdirectory named by its `parentTaskId`:
        *   Example: `task_memory_bank/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/`
*   **Files within Each Task's Directory:**
    *   **`metadata.json`**: Stores `parentTaskId`, `originalUserTask`, `taskStatus`, all `timestamps`, `finalAnswerFile` (e.g., "final_answer.md"), and `errorSummary`.
    *   **`plan.json`**: Stores the `generatedPlan` (JSON array of stages/steps). If replanning occurs, this might store the final active plan, or be versioned (e.g., `plan_v1.json`, `plan_v2.json`).
    *   **`execution.log.jsonl`**: Append-only log of execution events, each line a JSON object.
    *   **`final_answer.md`** (or `.txt`): Stores the `finalAnswer`.
    *   **`context_history/` (Subdirectory):** Contains plain text snapshots of context strings, named descriptively (e.g., `00_initial_context.txt`, `01_after_summarization_initial.txt`, `02_context_before_stage_1.txt`).

**Example Structure:**
```
task_memory_bank/
└── xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/  (parentTaskId)
    ├── metadata.json
    ├── plan.json
    ├── execution.log.jsonl
    ├── final_answer.md
    └── context_history/
        ├── 00_initial_context.txt
        └── ...
```

## 4. Content Schema for Key Files

*   **`metadata.json` (JSON Object):**
    ```json
    {
      "parentTaskId": "string_uuid",
      "originalUserTask": "string",
      "taskStatus": "string", // e.g., "COMPLETED_SUCCESS", "FAILED_EXECUTION"
      "finalAnswerFile": "string_or_null", // e.g., "final_answer.md"
      "errorSummary": { // Present if taskStatus indicates failure
        "failedAtStage": "number_or_string_or_null",
        "failedStepNarrative": "string_or_null",
        "errorMessage": "string_or_null"
      },
      "timestamps": {
        "createdAt": "ISO8601_datetime_string",
        "planGeneratedAt": "ISO8601_datetime_string_or_null",
        "executionStartedAt": "ISO8601_datetime_string_or_null",
        "synthesisStartedAt": "ISO8601_datetime_string_or_null",
        "completedAt": "ISO8601_datetime_string_or_null",
        "lastUpdatedAt": "ISO8601_datetime_string"
      },
      "version": "1.0" // Schema version
    }
    ```

*   **`plan.json` (JSON Array of Stages):**
    ```json
    [ // Array of stage objects
      {
        "stage": "number",
        "steps": [ // Array of step objects
          {
            "stepDescription": "string",
            "toolName": "string",
            "sub_task_input": {}, // Tool-specific input object
            "narrative_step": "string"
          }
        ]
      }
    ]
    ```

*   **`execution.log.jsonl` (Each line is a JSON Object):**
    ```json
    {
      "timestamp": "ISO8601_datetime_string",
      "stage": "number_or_string", // Stage number, or "Initial", "System"
      "sub_task_id": "string_uuid_or_null",
      "step_narrative": "string", // Narrative from plan, or system action description
      "tool_name": "string_or_null", // Tool used, or "System"
      "status": "string", // "COMPLETED", "FAILED", "SKIPPED", "SYSTEM_ACTION", "SYSTEM_ERROR"
      "input_payload": {}, // (Optional) Input given to the tool
      "result_data": "any_serializable_data_or_null",
      "error_info": { "message": "string", "details": "string_or_object_or_null" }, // If status is FAILED/SYSTEM_ERROR
      "duration_ms": "number_or_null"
    }
    ```

*   **`final_answer.md` (Markdown/Text):** The full textual answer.
*   **`context_history/*.txt` (Plain Text):** Raw context strings.

## 5. Agent Interaction Logic (Conceptual - When to Save)

The `OrchestratorAgent` (via a conceptual `MemoryManager` utility) would be responsible for writing to this structure at key points in its lifecycle:

*   **Task Reception:**
    *   Generate `parentTaskId`.
    *   Call `MemoryManager.createTaskMemory(parentTaskId, originalUserTask)` to create the task directory and initialize `metadata.json` (status: "RECEIVED", `createdAt`, `lastUpdatedAt`).
*   **After Initial Planning:**
    *   `MemoryManager.savePlan(parentTaskId, generatedPlanArray)`.
    *   `MemoryManager.updateTaskStatus(parentTaskId, "PLANNING_COMPLETED")`.
    *   `MemoryManager.updateTimestamp(parentTaskId, "planGeneratedAt")`.
*   **During Plan Execution (`executePlanLoop`):**
    *   **Start of Loop:** Update status to "EXECUTING_PLAN", set `executionStartedAt`.
    *   **Context Snapshots:** Save to `context_history/` before/after summarization calls using `MemoryManager.saveContextSnapshot()`. Log system actions for summarization via `MemoryManager.appendToExecutionLog()`.
    *   **Per Step/Event:** After each tool execution or system event (like replanning triggers), append the detailed `logEntry` object to `execution.log.jsonl` using `MemoryManager.appendToExecutionLog()`. Update `lastUpdatedAt`.
*   **After Replanning Attempt:**
    *   If a new plan segment is generated, save it (e.g., `MemoryManager.savePlan(parentTaskId, newPlanSegment, "replan_1")`). Update status to "EXECUTING_REPLAN".
*   **After Final Answer Synthesis:**
    *   Set `synthesisStartedAt`.
    *   If successful: `MemoryManager.saveFinalAnswer()`, update status to "COMPLETED_SUCCESS".
    *   If synthesis fails: Update status to "FAILED_SYNTHESIS" with error details.
    *   Set `completedAt`, `lastUpdatedAt`.
*   **On Unrecoverable Execution Failure:**
    *   Update status in `metadata.json` (e.g., "FAILED_EXECUTION") with `errorSummary`.
    *   Set `completedAt`, `lastUpdatedAt`.
```
